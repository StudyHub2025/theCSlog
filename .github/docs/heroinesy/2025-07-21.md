## Ch2. 명령어

### 명령어
- 오퍼랜드(operand) : 명령어를 수행할 대상 (데이터, 데이터의 주소)
- 연산코드(op-code) : 오퍼랜드로 수행할 동작 
  - 데이터 전송 (PUSH, POP)
  - 산술/논리 연산 (AND/OR/NOT)
  - 제어 흐름 변경 (CALL,RET)
  - 입출력 제어 (READ, WRITE)

### 주소 지정
메모리에 직접 접근하는 건 속도가 느리다. -> 레지스터를 이용

- 즉시 주소 지정 : 연산할 데이터를 필드에 직접 명시, 가장 속도가 빠르지만 데이터 크기의 제한이 있다
- 직접 주소 지정 : 필드에 유효주소를 명시, 유효주소 : 연산 데이터가 저장된 메모리 주소
- 간접 주소 지정 : 필드에 유효주소의 주소를 명시, 직접 주소보다 더 느림
- 레지스터 주소 지정 : 오퍼랜드가 저장된 레지스터 이름이 명령어에 직접 명시됨. 메모리 접근보다 빠름.
- 레지스터 간접 주소 지정 : 연산 데이터를 메모리에 저장하고 해당 유효 주소를 레지스터에 명시

## Ch3. 데이터

### 부동 소수점(IEEE 754 표준)
```
±(1.M) × 2^(E - Bias)
(여기서 Bias = 127 for float, 1023 for double)
```
: 이진수를 바이어스 값을 더해서 저장
- 10진수로 정확히 표현되지 않는 이진 소수가 존재하여, 무한 반복 소수처럼 근사 저장됨
실수를 다루는 double 타입은 사칙 연산시 내부적으로 수를 저장할 때 이진수의 근사치를 저장하기 때문에 원하는 결과를 못얻어내기 때문에 BigDecimal을 사용
[실수 표현/부동 소수점 원리 정리 (Inpa 블로그)](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%8B%A4%EC%88%98-%ED%91%9C%ED%98%84%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%9B%90%EB%A6%AC-%ED%95%9C%EB%88%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)