## Ch 4. 동기화와 교착상태

### 프로세스 동기화
동기화
- 실행 순서 제어 : 프로세스를 올바른 순서로 실행
- 상호 배제 : 자원의 일관성을 위해 동시에 접근해서는 안되는 자원에 하나만 접근

Critical Section
- 공유 자원 : 공동의 자원
- 임계 구역 : 동시에 접근하면 문제가 발생할 수 있는 공유 자원에 접근하는 코드

### 뮤텍스와 세마포어

동기화 해결의 세가지 원칙
1. 상호 배체 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 대기해야함
2. 진행 : 어떤 프로세스도 임계 구역에 진입하지 않았다면 진입이 가능해야함
3. 유한 대기 : 한 프로세스가 임계 구역 진임을 위해 대기하고 있다면 언젠간 진입이 가능해야함

- 뮤텍스 락 (Mutex Lock)
자물쇠 역할 : lock
자물쇠  잠그기 : acquire 
자물쇠 열기 : release

```
acquire() {
    while (lock == true)
        ;
    lock = true
}
release() {
    lock = false;
}
```

- 세마포 (semaphore)
공유 자원이 여러 개 있을 경우도 동기화 가능

1. 변수 S : 임계 구역에 진입할 수 있는 프로세스의 개수
2. wait 함수 : 임계구역에 들어가도 좋은지, 기다려야 할지를 알려주는 함수
3. signal 함수 : 임계구역 앞에서 기다리는 프로세스에게 '이제 가도 좋다'고 신호를 주는 함수

```
wait(){
    while( S <= 0 )
;
    S--;
}
```
```
Signal(){
    S++
}
```
### 교착상태 (DeadLock)

발생 조건
1. 상호 배제: 자원을 동시에 사용할 수 없음
2. 점유와 대기: 자원을 점유한 상태에서 다른 자원을 기다림
3. 비선점: 자원을 강제로 빼앗을 수 없음
4. 원형 대기: 자원을 순환적으로 기다리는 상태

해결방안
1. 교착 상태 예방
: 발생 조건 네가지 중 하나라도 없애는 것
- 자원을 공유 가능 -> 모든 자원에 대해 적용은 불가
- 특성 프로세스에 자원을 모두 할당, 할당 X -> 자원의 활용률 저하
- 비선점 조건 제거 -> 모든 자원에 대해 적용은 불가
- 자원에 번호를 매기거나 오름차순으로 자원 할당

2. 교착 상태 회피
교착 상태가 발생하는 이유를 자원의 무분별한 할당으로 간주
-> 교착상태가 발생하지 않을 정도로만 조금씩 자원을 할당
ex. Banker's algorithrm

3. 교착 상태 검출 후 회복
- 선점을 통한 회복
- 프로세스 강제 종료를 통한 회복

## Ch 5. 가상 메모리 관리

### 페이징과 페이지 테이블

스와핑 (Swapping): 프로세스를 보조 기억장치의 일부 영역으로 내보내고, 필요한 프로세스를 메모리에 적재하는 기법

- 스왑 아웃: 프로세스를 보조 기억장치로 내보냄
- 스왑 인: 스왑 아웃된 프로세스를 다시 메모리에 적재
스왑 영역: 스왑 아웃된 프로세스가 저장되는 보조 기억장치의 영역 (운영체제 설치 시 설정)

; 스와핑을 사용하면 현재 메모리보다 더 큰 영역을 적재할 수 있음

- 연속 메모리 할당의 부작용 : 외부 단편화
ex. 총량이 50MB지만 실행되고 종료되길 반복하면서의 빈공간(20MB, 30MB)이기 때문에 50MB를 적제하지 못하는 메모리 낭비 현상 
-> 페이징(paging) : 만약 메모리와 프로세스를 일정 단위(프레임, frame)로 자르고, 프로세스를 적제하는 기법 ex. 10MB

- 가상 메모리 : 프로세스의 일부만을 적재하여 실제 물리 메모리보다 큰 프로세스를 실행

- 세그멘테이션 : 논리적으로 유의미한 프레임으로 사용, 외부 단편화 발생 가능

- 페이지 테이블 : 프레임와 페이지의 매핑 정보를 담고 있는 표 형태의 데이터
페이지 테이블을 사용하면 불연속적으로 배치되어 있는 페이지가 현재 물리 메모리 내에 어디에 적재되어있는지 CPU가 판별할 수 있음

- 페이지 테이블 베이스 레지스터 (PTBR)
: 각 프로세스의 페이지 테이블 위치를 가리키는 레지스터

- 페이지 테이블을 캐시 메모리에 담아서 사용 (TLB)

- 페이지 폴트 발생 (interrupt)
1. 작업 내역 백업
2. 페이지 폴트 루틴 실행 - 접근하려는 페이지 적재
3. 유효 빈트 1로 변경
4. 접근하려는 페이지 접근

페이지 테이블 내 정보
- 페이지 번호
- 프레임 번호
- 유효 비트
- 보호 비트 (rwx)
- 참조 비트
- 수정 비트

### 요구 패이징
순수 요구 페이징 (페이지 폴트)
스래싱 (Thrashing) : 프로세스 실행 시간보다 페이징에 더 많은 시간이 소요되는 문제 -> 성능 저하

### 페이지 교체 알고리즘
좋은 알고리즘 : 페이지 폴트를 적게 일으키는 알고리즘

- FIFO (First-In First-Out)
- 2차 기회 FIFO 
: FIFO + 참조 비트가 1일 경우, 이를 0으로 변경 후 한번 더 기회 부여 -> 참조 비트가 0일 경우 페이지-아웃
- 최적 페이지 교체 알고리즘 : 앞으로의 사용 빈도가 가장 낮은 페이지부터 페이지-아웃
- LRU (Least Recently Used)

## Ch 6. 파일 시스템

### 파일 시스템
- 파티셔닝(partitioning) : 보조기억장치의 영역을 구획하는 작업
  - 파티션(partition) : 보조기억장치에서 구획된 영역
- 포매팅 : 파일 시스템을 만드는 작업

- FAT 기반 파일 시스템(USB, SD카드): 디렉터리 엔드리에 파일 속성 표현
- 유닉스(Inode) 기반 파일 시스템 : 색인 블록을 활용한 파일 시스템

- 색인 블록 (Inode) : 어떤 파일에 접근하기 위한 블록정보를 전부 저장하고 있는 블록

- 저널링 파일 시스템 : 파일 시스템에 크래쉬가 발생했을 때 빠르게 복구하기 위한 방법
1. 작업 직전 파티션의 로그 영역에 로그를 남긴다 (commit)
2. 로그를 남긴 후 작업 수행
3. 작업이 끝난 후 로그 삭제