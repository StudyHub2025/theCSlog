# 운영체제

## Ch 2. 프로세스와 스레드

### 프로세스 생성과 상태
대표적인 프로세스 상태
- 준비 상태(W)
- 실행 상태(R)
- 대기 상태(W)
- Zombie (Z) : 프로세스가 종료된 후 자원은 반환되었지만, 부모 프로세스가 종료 상태를 회수하지 않아 PCB가 커널 영역에 남아있는 상태. 가능한 방지하는 것이 중요.

- 준비 상태에서 cpu 할당을 기다림
- 실행 상태 → 타임아웃 발생 시 → 준비 상태로 전환
- 실행 상태 → 입출력 이벤트 발생 시 → 대기 상태로 전환

프로세스 생성 관련 함수 fork, exec
- fork : 부모 프로세스의 복사본을 생성, 동일한 프로세스를 두번 호출 (PID 값은 다름)
- exec : 덮어쓰기, 기존 내용을 변경 (PID 값은 동일)

### 스레드
: 프로세스를 구성하는 실행 흐름의 단위

| 항목             | 멀티 프로세스                      | 멀티 스레드                        |
|------------------|------------------------------------|------------------------------------|
| 자원 공유 여부   | 자원 공유 X                         | 자원 공유 O                        |
| 안정성           | 하나의 프로세스 오류 시 전체 영향 X | 하나의 스레드 오류 시 전체 영향 O |
| 메모리 사용량     | 상대적으로 많음                    | 상대적으로 적음                   |
| 예시             | 웹 브라우저의 각 탭               | 하나의 탭 내 여러 작업            |


- 멀티 프로세스 : 메모리 소요량이 크다. 단 자원 공유를 하지 않기 때문에 하나의 탭에서 문제가 생길 시 해당 탭만 종료
- 멀티 스레드 : 자원을 공유하기 때문에 하나의 탭에서 문제가 발생시, 브라우저 자체 종료

+ 기본적으로 프로세스는 자원을 공유하지 않지만, 프로세스 간 통신을 통해 자원 공유는 가능하다. (IPC)

---
## Ch 3. CPU 스케줄링

### 스케줄링 큐
특정 자원을 이용하는 프로세스들이 서는 줄, 운영체제는 이 프로세스를 토대로 자원을 할당

- 선점형 스케줄링 : CPU를 일정 시간만 할당하고 다른 프로세스로 전환,
                문맥 교환(Context Switching)으로 인한 오버헤드 발생 가능성 있음
- 비선점형 스케줄링 : CPU를 할당받은 프로세스가 작업을 완료할 때까지 점유

### CPU 스케줄링 알고리즘
1. 선입 선처리 스케줄링 (FCFS, First-Come First-Served) (FIFO)
- 준비 큐에 삽입된 순서대로 실행
- 호위 효과(convoy effect) 발생 가능

2. 최단 작업 우선 스케줄링 (SJF, Shortest Job First)
- CPU 사용 시간이 짧은 프로세스부터 실행
- 호위 효과를 방지할 수 있음

3. 라운드 로빈 스케줄링 (RR)
- FCFS 방식에 타임 슬라이스(Time Slice)를 적용
- 타임 슬라이스만큼 실행 후 문맥 교환 발생

4. 최소 잔여 시간 우선 스케줄링 (SRT)
- SJF의 선점형 버전
- 남은 실행 시간이 가장 짧은 프로세스에 CPU 우선 할당

5. 우선 순위 스케줄링
- 우선순위가 높은 프로세스부터 실행
- 아사(Starvation) 현상 발생 가능  
    → 해결 방법: **에이징(Aging)**  
    - 대기 시간이 길어질수록 우선순위를 점진적으로 높이는 방식

6. 다단계 큐 스케줄링 : 우선 순위별로 준비 큐를 여러 개 사용 (아사현상)
- 프로세스 유형 별로 큐 구분
- 큐 별로 다른 스케줄링 알고리즘 적용
- 큐 별로 다른 타임 슬라이스 적용

7. 다단계 피드백 큐 스케줄링
- 다단계 큐 스케줄링 + 큐 간의 이동 가능 
- 낮은 우선순위 큐에 오래 머무는 프로세스를 상위 큐로 이동시켜 아사현상 방지