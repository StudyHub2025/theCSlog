## Ch 5. 응용 계층

네트워크 상에서 호스틀르 특정 지을 수 있는 **주소**
- MAC 주소
- IP 주소

이는 마치 전화번호와 같다!<br>
But, 모든 전화번호를 외우기 힘들듯 모든 IP/MAC 주소를 알고 있기란 어렵다
+ IP 주소는 언제든 변경될 수 있다.

그래서 사용하는 전화번호부
### DNS

- 전화번호부와 유사한 기능을 수행하는 DNS
- 사람이 기억하기 쉬운 도메인 이름과 호스트를 특정지을 주소를 매핑

* 도메인 : 호스트에 부여되는 문자열 이름 (e.g. fastcampus.co.kr)

hosts파일 - 개인 전화번호부<br>
모든 전화번호를 관리하기 어렵다

- 계층적 도메인 구조<br>
[DNS 루트 서버 | Cloudflare](https://www.cloudflare.com/ko-kr/learning/dns/glossary/dns-root-server/)

루트 네임 서버<br>
[https://ko.wikipedia.org/wiki/루트_네임_서 `버](https://ko.wikipedia.org/wiki/루트_네임_서버)

TLD (Top-Level-Domain)<br>
[인터넷 최상위 도메인 목록](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EC%B5%9C%EC%83%81%EC%9C%84_%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%AA%A9%EB%A1%9D)

Second Level Domain<br>
Third Level Domain<br>
Forth Level Domain (보통 호스트를 지칭)

서브 도메인 (하위 도메인)
- 도메인의 일부인 도메인
    - naver.com → maps.naver.com
    - wikipedia.com → en.wikipedia.com

각 도메인을 담당하는 도메인 서버
- ROOT 네임 서버
- TLD 서버
- Authoritative DNS 서버(책임 DNS 서버) : 찾고자 하는 도메인의 IP주소를 저장하는 최종 서버
- local DNS 서버 : 클라이언트가 가장 먼저 찾는 DNS 서버 (DNS Resolver)

local DNS 서버 주소 명시적 설정 ← Public DNS<br>
[Public DNS  |  Google for Developers](https://developers.google.com/speed/public-dns?hl=ko)<br>
[1.1.1.1 — 개인정보 보호를 최우선으로 하는 가장 빠른 인터넷 DNS 확인자 중 하나](https://one.one.one.one/ko-KR/dns/)

> Public DNS 중에 1.1.1.1이 클라우드플레어 DNS 서버고,<br>
> 구글 DNS 서버가 8.8.8.8이나 8.8.4.4이 local DNS 서버였었나..

local DNS 서버 주소 자동 설정 ← ISP
- 반복적 질의
- 재귀적 질의

DNS 서버는 무엇을 저장하고 있을까?<br>
→ DNS 레코드 (자원 레코드)

도메인 구입 후 DNS 레코드 설정
- A 레코드 : 도메인에 대한 IPv4 주소
- AAAA 레코드 : 도메인에 대한 IPv6 주소
- CNAME 레코드 : 도메인에 대한 별칭
- NS 레코드 : 네임 서버 주소
- SOA 레코드 : 도메인에 대한 관리자 정보

DNS 캐시

- TTL 기간동안 DNS 저장

```bash
> ipconfig /displaydns
```

### 자원과 자원의 식별
URI (Uniform Resource Identifier)
URL (Uniform Resource Locator)

네트워크 상에서의 ‘자원’
- 네트워크로 주고받을 수 있는 모든 정보
- 파일, 이미지, 동영상, HTML, XML, JSON, …

네트워크 상에서의 ‘자원’이 필요하다면 자원을 요청해야 함<br>
자원을 요청하고 요청한 자원을 응답하려면 자원을 식별(identify)할 수 있어야 == 자원의 식별자(identifier)가 있어야<br>
자원의 식별자 == Uniform Resource Identifier<br>
URI는 자원을 식별할 수 있는 문자열

URI의 분류<br>
URI는 위치 혹은 이름으로 분류 가능하다
- **URL : 위치 기반 자원 식별(Locator)**
- URN : 이름 기반 자원 식별(Name)

URI는 위치 혹은 이름으로 분류 가능하다<br>
[www.ietf.org](https://www.ietf.org/rfc/rfc3986.txt)

URL 구성 요소
- scheme
    - 일반적으로 프로토콜 이름 명시
    - **https**://iana.org/assignments/uri-schemes/uri-schemes/xhtml
    - **ftp**://ftp.kernel.org/
    - **http**://example.com
- authority = [ userinfo “@” ] host [ “:” port ]
    - 사용자 이름을 이용한 인증 가능 - 생략 가능
    - 호스트 이름 (도메인 이름 혹은 IP 주소)
    - 포트 번호 - 생략 가능
- path
    - 자원이 있는 경로
    - iana.org**/_img/2025.1/iana-logo-header-notext.svg**
    - myblog**/posts/50**
- query
    - key:value 형태로 서버에 전달할 문자 형태의 파라미터
    - ? 로 시작, & (혹은 ;)로 다수의 query 구분
    - google.com/search**?q=fastcampus&hl=ko**
- fragment
    - 자원의 조각(fragment)를 가리키는 데에 사용 (#로 구분) - HTML 북마크 기능
    - docs.python.org/ko/dev/howto/sockets.html**#creating-a-socker**
    - docs.python.org/ko/dev/howto/sockets.html**#ipc**

서버(server)-클라이언트(client)의 개념을 되짚어보자
- 서버는 대답하는 대상(response)
- 클라이언트는 요청하는 대상(request)

서버
- 웹 서버
- 웹 어플리케이션 서버 (WAS)

서버가 응답해야 하는 자원
- 정적인 자원 : 언제/어디서/누가 봐도 변하지 앟는 정보 (e.g. HTML, 이미지, 동영상, …)
- 동적인 자원 : 언제/어디서/누가 보는지에 따라 **변할 수 있는 정보**<br>
  → **여기서 주로 사용되는 것이 데이터베이스**


- 정적인 자원을 응답하는 **웹 서버**
- 동적인 정보를 생성해 응답하는 **웹 어플리케이션 서버**

정적 정보 응답<br>
동적 정보 응답

현재 HTTP의 기본 특성
- 요청-응답 기반 클라이언트-서버 구조 프로토콜
- 미디어-독립적 프로토콜
- 비연결성 프로토콜
- 스테이트리스 프로토콜
- 지속 연결 프로토콜

요청-응답 기반 클라이언트-서버 구조
- HTTP 클라이언트 (HTTP 요청 메시지)
- HTTP 서버 (HTTP 응답 메세지)
- 오해 방지 : **서버 간에도 HTTP 메세지를 주고받을 수 있음**

미디어-독립적
- 어떤 형태의 데이터도 HTTP 메세지를 보낼 수 있음<br>
HTML, 이미지, JSON, XML, 파일, 영상, 이미지 등

비연결성
- HTTP 1.0, HTTP 1.1, HTTP 2.0은 TCP 기반
- TCP는 연결성 프로토콜
- But, HTTP는 비연결성 프로토콜
- 다수의 클라이언트가 연결을 시도할 경우
- 연결을 유지하는 동안 서버의 자원 소모가 너무 크다!

스테이트리스
- 서버는 클라이언트의 상태를 기억하지 않는다
- 왜 스테이트리스 프로토콜일까?

HTTP가 스테이트풀 프로토콜일 경우
- 클라이언트는 한 서버에 종속됨
- 여러 요청을 보내야 할 경우 한 서버에만 요청해야 함

그런데<br>
서버의 IP가 바뀐다면?<br>
요청을 보낸 서버에 장애가 생긴다면?<br>
서버가 여러 대 있다면?

HTTP가 스테이트리스 프로토콜이기 때문에

- 클라이언트는 한 서버에 종속될 필요가 없어짐
- 여러 번 요청을 보내야 할 경우 여러 서버에 요청할 수 있음<br>
**서버의 확장이 용이해진다**<br>
  지속 연결 (=Keep-Alive)


- 연결할 때마다 3-way handshake?<br>
  → 혼잡 증가<br>
  → 시간 지연 증가(handshake, slow start 시간)
- 하나의 연결을 사용해 여러 개의 HTTP 요청/응답 주고받기


HTTP 버전별 특성
- HTTP 0.9 : 단일한 요청 방법(GET 메서드), 비지속 연결, 별다른 기능 X
- HTTP 1.0 : 다양한 요청 방법과 헤더 추가
- **HTTP 1.1** : 지속 연결 기능 추가
- **HTTP 2.0** :  요청 순서대로 응답을 반환할 필요 없음, 헤더 압축
- HTTP 3.0 : UDP 기반 프로토콜인 QUIC로 변경
  HTTP 메시지

HTTP-message = **start-line**<br>
                    * ( header-field CRLF )<br>
                    CRLF<br>
                    [ message-body ]

HTTP 요청 헤더 - Start line
- HTTP 메서드 (공백) 요청 대상 (공백) HTTP 버전 (개행)

HTTP 메서드 : 서버에게 요청할 동작 (해당 자원으로 어떤 동작을 요청할지)
- GET : 자원 조회 (”갖다 줘”)
- POST : 요청할 데이터 처리 (”이 데이터 처리해 줘”)
- PUT : 자원 덮어쓰기
- PATCH : 자원 부분 변경
- DELETE : 자원 삭제<br>
이외에도 HEAD, OPTIONS, TRACE, CONNECT

GET 요청
- 리소스 조회에 사용
- 일반적으로 쿼리 문자열을 사용하되, 본문은 없음
- “갖다 줘”

POST 요청
- 메세지 본문으로 처리할 데이터 전송
- 메세지 본문에 해당하는 데이터 처리하도록 요청
- 어떻게 처리할지는 서바가 결정 (e.g. 새 자원 생성, 가공)

PUT 요청
- 자원 덮어쓰기
- 자원이 있다면 본문으로 보낸 데이터로 대체
- 자원이 없다면 본문으로 보낸 데이터로 생성
- “이 자원으로 대체해줘”

PATCH 요청
- 자원의 일부분 변경

DELETE 요청
- 자원 삭제

멱등성 : 여러 번 동일한 요청을 보내도 첫 요청 결과와 같은가?<br>
캐시 가능성 : 응답 결과를 캐시해서 사용할 수 있는가?

요청 대상
- 요청할 자원의 위치

HTTP 버전
- HTTP 1.1, HTTP 2.0

HTTP 응답 헤더 - Start line
- HTTP 버전 (공백) 응답 코드 (공백) 이유 문구 (개행)

응답 코드
- 2XX : 성공
- 3XX : 리다이렉션 (이 요청을 처리하려면 추가적인 처리가 필요함)
- 4XX : 클라이언트 오류
- 5XX : 서버 오류

2XX 상태 코드
- 200 OK : 요청 성공 (GET)
- 201 Created : 요청 성공, 새로운 자원 생성됨 (POST)
- 202 Accepted : 요청 성공, 처리는 아직 미완료
- 204 No Content : 요청 성공, 응답할 데이터 없음

3XX : 리다이렉션 상태 코드
- 응답의 Location 헤더를 통해 특정 위치로 이동

4XX 상태 코드 : 클라이언트에 의해 생긴 오류
- 401 Unauthorized : 미인증
- 403 Forbidden : 금지된 자원에 접근 (자원에 접근할 권한이 없음)
- 404 Not Found : 요청한 자원 없음 (공개한 자원이 아님)

5XX 상태 코드 : 서버에 의한 오류
- 500 Internet Server Error : 서버 오류
- 503 Service Unavailable : 현재 이용 가능하지 않음

요청 헤더 필드
- 다양한 요청 헤더 필드

HTTP 메시지

HTTP-message = ****start-line
                    * ( **header-field** CRLF )
                    CRLF
                    [ message-body ]

### HTTP 헤더
header-field = field name “:” field-value
- 메세지 전송에 필요한 부가 정보

대표적인 헤더 정보
- Host : 요청 호스트에 대한 호스트명 + 포트 정보
- Date : 메세지 생성 시간
- Referer :  직전에 머물렀던 URL
- User-Agent : 클라이언트 소프트웨어, 브라우저 명칭과 정보
- Server : 서버 소프트웨어 명칭과 정보
- Connection : keep-alive일 경우, 킵 얼라이브
- Location : 리다이렉트시 이동할 경로

[User-Agent - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Reference/Headers/User-Agent)

[MIME 타입 (IANA 미디어 타입) - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/MIME_types#Common_types)

```bash
$ curl
# $curl -X <요청 메서드> URL (디폴트: GET)
# $curl -I <URL> # 헤더만 출력
# $curl -i <URL> # 헤더+본문 출력
# $curl -o file.txt <URL> # 결과 저장
# $curl -d <전송할 데이터> -X POST <URL>
# $curl -H <전송할 헤더> -X POST <URL>
```

[JSONPlaceholder - Free Fake REST API](https://jsonplaceholder.typicode.com/)

더미데이터 사이트

https://jsonplaceholder.typicode.com/posts

https://jsonplaceholder.typicode.com/posts/1

https://jsonplaceholder.typicode.com/users

https://jsonplaceholder.typicode.com/users/1

https://jsonplaceholder.typicode.com/posts?userId=1

https://jsonplaceholder.typicode.com/posts?userId=1&id=1

### 캐시(Cache)

네트워크에서의 캐시란?
- HTTP는 상태를 유지하지 않는다
- 그렇다면 자원을 요청할 때마다 자원은 새롭게 응답될까?
- 서버의 지연을 줄이기 위해 웹 페이지, 이미지 등의 **자원 사본**을 임시 저장하는 웹 기술
- 캐시된 자원이 저장되는 공간 : 클라이언트(브라우저) 혹은 특별한 서버(캐시 서버, 프록시 서버)

cache-control 헤더
- cache-control 헤더로 캐시 기능을 알린다
- cache-control: max-age=숫자(초) 캐시한 자원의 지속 시간
- cache-control: no-cache 캐시 가능한 자원이나 항상 origin 서버에 검증하기
- cache-control: no-store 캐시하면 안 될 자원

캐시된 자원에는 유효 기간이 있다
- 해당 자원이 언제 마지막으로 변경되었는지를 알리는 **Last-Modified** 헤더<br>
  e.g. Last-Modified: 2023년 8월 1일 09:00:00


캐시된 자원의 변경
- 캐시란 서버의 지연을 줄이기 위해 웹 페이지, 이미지 등의 자원 **사본**을 임시 저장하는 웹 기술
- 캐시된 자원이 변경되었다면?

캐시된 자원의 변경 -1
- 클라이언트는 요청시 **if-modified-since** 헤더로 특정 시점 이후 자원 변경 여부를 묻는다
- 만일 변경되었다면 다시 다운로드
- 만일 변경되지 않았다면 서버는 **304 Not Modified** 응답을 보낸다<br>
  → “자원 변경 안됐으니까, 캐시로 Redirect 해라”


캐시된 자원의 변경 -2
- Etag를 통해 자원의 변경 여부 감지 가능
- 서버는 캐시된 자연에 **Etag**(자원에 붙이는 버전 이름)라는 식별 문자를 붙이고
- 클라이언트는 **If-None-Match** 헤더를 통해 해당 Etag가 변경되었는지를 물어본다

### 쿠키(Cookie)

쿠키란?
- HTTP는 상태를 유지하지 않는 프로토콜
- 그럼 요청을 보낼 때마다 모든 정보를 URL 쿼리, HTTP 바디로 보내야 할까?
- 만일 그렇다면 이런 기능은 어떻게 구현할 수 있는 걸까? - 오늘은 그만 보기
- 서버로부터 받은 정보를 클라이언트 측(웹 브라우저)에 임시 저장되는 **이름=값** 형태의 데이터
- **유효 기간**이 있음
- 쿠키를 전송할 **도메인**과 **경로**가 정해져 있음

쿠키(cookie) 확인해보기 : 브라우저 → 개발자 도구 → Application → Storage → Cookies
- 서버가 **Set-Cookie** 헤더로 쿠키를 전달하면, 클라이언트는 쿠키를 저장하여 다음 HTTP 요청의 **Cookie** 헤더로 활용한다

쿠키(cookie)의 도메인
- Set-Cookie: **domain=example.com**
- example.com (을 비롯한 서브 도메인)에 접근할 때 쿠키 활용

쿠키(cookie)의 경로
- Set-Cookie: **path=/**
- path에 명시된 경로 하위 경로에서 쿠키 활용
- path=/posts

→ path=/posts/1, path=/posts/2, path=/posts/3

쿠키(cookie)의 유효 기간
- Set-Cookie: **expires=Wed, 10 Aug 2023 12:00:00 GMT**
- Set-Cookie: **max-age=1000**

쿠키(cookie)는 보안에 민감하다

쿠키 정보는 탈취당하지 않도록 주의 필요

### **쿠키(cookie)와 세션(session)**

쿠키의 저장/관리 주체가 클라이언트(브라우저)라면<br>
세션의 저장/관리 주체는 서버<br>
서버는 클라이언트를 식별할 수 있는 세션 ID를 제공하고,<br>
클라이언트는 서버에게 세션 ID를 (쿠키로) 넘겨 호스트를 식별하게 할 수 있다

쿠키(cookie)의 보안 기능
- Secure<br>
HTTPS인 경우에만 전송

- HTTPOnly<br>
자바스크립트에서 접근 불가 (document.cookie)<br>
XSS 공격 방지

컨텐츠 협상 (Content negotiation)

- 클라이언트가 원하는 컨텐츠를 받을 수 있도록 서버에게 부탁(힌트제공)하는 기능
- 컨텐츠 타입, 언어, 인코딩 방법 등 클라이언트 맞춤 컨텐츠 제공 기능
- **Accept(-X)** 헤더 이용
- Accept : 클라이언트가 선호하는 컨텐츠 타입
- Accept-Encoding : 클라이언트가 선호하는 인코딩
- Accept-Language : 클라이언트가 선호하는 언어
- 여러 맞춤 요청을 보낼 수 있음
- Accept: text/html, application/xml, … (복수 가능)
- 여러 맞춤 요청을 보낼 때 Quality Value 값을 기준으로 우선순위를 매길 수 있음
- 0 ≤ Quality Value(q) ≤ 1
- 클수록 우선순위가 높음 (아무것도 안적혀있으면 1)
- Accept: text/html, text/plain;q=0.9, text/*;q=0.8, */*;q=0.7
- Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7

컨텐츠 협상 (Content negotiation) 예시
```bash
Accept-Language: en-US, en;q=0.8, es;q=0.5
```

클라이언트가 영어(미국), 영어(일반), 스페인어의 언어 형식을 받을 수 있으며,<br>
영어(미국)에 높은 우선순위를 두고(q=1.0)<br>
영어(일반)과 스페인어는 상대적으로 낮은 우선순위를 갖는다(q=0.8 및 q=0.5)

```bash
	Accept: application/json;q=1.0, text/html;q=0.8, */*;q=0.1
```

클라이언트가 JSON 형식의 미디어를 가장 우선으로 받고,<br>
그 다음으로 HTML 형식의 미더어를 받을 수 있으며,<br>
다른 형식의 미디어도 가능하나 우선순위는 낮음