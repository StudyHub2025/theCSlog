## **Ch 4. 전송 계층**

전송 계층의 역할
- 응용 계층의 어플리케이션 프로세스 식별: **포트(port)**
- 네트워크 계층의 신뢰성/연결성 확립

### 포트
- 포트 번호는 16비트로 표현 가능(65536개)
- 포트 범위 : 0번부터 65535번까지

| 포트 종류 | 포트 번호 범위 |
| --- | --- |
| 잘 알려진 포트 (well known port) | 0~1023 |
| 등록된 포트 (registered port) | 1024~49151 |
| 동적 포트 (dynamic port) | 49152~65535 |

잘 알려진 포트, 웰 노운 포트, 시스템 포트
- 널리 알려진, 유명한 포트

| 포트 번호 | 설명 |
| --- | --- |
| 20, 21 | FTP |
| 22 | SSH |
| 25 | SMTP |
| 53 | DNS |
| 67, 68 | DHCP |
| 80 | HTTP |
| 443 | HTTPS |

등록된 포트
- 잘 알려진 포트에 비해서는 덜 범용적이지만 흔히 사용되는 애플리케이션

| 포트 번호 | 설명 |
| --- | --- |
| 1194 | OpenVPN |
| 1433 | Microsoft SQL Server 데이터베이스 |
| 3306 | MySQL 데이터베이스 |
| 6379 | Redis |
| 8080 | HTTP 대체 |

동적 포트, 사설 포트, 임시 포트
- 사용자가 자유롭게 할당 가능한 포트

서버는 일반적으로 잘 알려진 포트와 등록된 포트로 동작<br>
클라이언트는 일반적으로 동적 포트로 동작

NAT 공인 IP 주소와 사설 IP 주소 간의 변환 기능
- **하나의 공인 IP 주소를 여러 사설 IP 주소가 공유 가능 ← 여기서 포트 활용**
- IP 주소 부족 문제 해결

NAT 변환 테이블

| 1.2.3.4:6200 | 192.168.0.5:1025 |
| --- | --- |
| 1.2.3.4:6201 | 192.168.0.5:1025 |

### TCP 세그먼트
MSS : TCP 세그먼트로 보낼 수 있는 최대 크기

TCP 세그먼트 구조

- 출발지 포트
- 목적지 포트
- 순서 번호 : 송수신되는 세그먼트 데이터 첫 바이트에 부여되는 번호
- 확인 응답 번호 : 순서 번호에 대한 응답 (다음으로 수신받길 기대하는 바이트 번호)
- 제어 비트
    - ACK : 세그먼트 승인을 나타내는 비트
    - SYN : 연결 수립을 위한 비트
    - FIN : 연결을 끝내기 위한 비트
    - RST : 연결을 리셋하기 위한 비트
    - …
- 윈도우 : 수신지 윈도우 크기. 한 번에 수신 받고자 하는 양 (흐름 제어에서 언급)
- …

### UDP 데이터그램
UDP는 IP 패킷을 감싸는 껍데기일 뿐
- 비연결성/비신뢰성 프로토콜
- TCP의 재전송/흐름 제어/혼잡 제어 등의 기능 없음

모두 TCP 세그먼트에 있는 정보들
+ 체크섬 필드는 신뢰성과는 관련이 없다

하나 하나 확인히 보내는 TCP
빠르게 마구 던지는 UDP
최근 빠른 성능으로 각광받는 UDP
- HTTP/3, NTP, RIP, DNS, DHCP

### TCP
TCP는 연결형 프로토콜
1. 연결 설정 ← **Three-way handshake**
2. 데이터 송수신
3. 연결 종료

Three-way handshake<br>
엑티브 오픈, 패스트 오픈 호스트
연결 종료

액티브 클로즈 호스트는 마지막 ACK을 보낸 뒤<br>
**일정 시간을 기다리고** 연결을 종료한다
- 마지막 ACK 세그먼트의 유실 대비
- 또 다른 연결 과정에서의 패킷 혼선 방지

TCP는 연결형 프로토콜
+ TCP는 스테이트풀(stateful) 프로토콜

현재 연결 상태를 나타내기 위해 다양한 상태(state) 활용

TCP의 가능한 상태 목록
- CLOSED
- LISTEN
- SYN-SENT
- SYN-RECEIVED
- ESTABLISHED
- FIN-WAIT-1
- FIN-WAIT-2
- CLOSE-WAIT
- CLOSING
- LAST-ACK
- TIME-WAIT

CLOSED : 아무런 연결이 없는 상태

LISTEN, SYN-SENT, SYN-RECEIVED : 연결 수립 도중 사용되는 상태
- LISTEN : SYN 세그먼트를 기다리는 상태 (서버 호스트)
- SYN-SENT : SYN 세그먼트를 보낸 뒤 SYN+ACK 세그먼트 대기
- SYN-RECEIVED : SYN+ACK 세그먼트를 보낸 뒤 그에 대한 ACK 대기
- 
ESTABLISHED : 연결되어 있는 상태
- Three-way handshake 끝났을 경우
- 데이터 송수신 가능

FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT : 연결 해제시 사용되는 상태
- CLOSING : 상대 FIN 세그먼트에 ACK 세그먼트를 보냈지만 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못한 상태 ( 보통 동시에 연결을 종료하려 할 때)

액티브 클로즈 호스트는 마지막 ACK을 보낸 뒤<br>
**TIME_WAIT 상태에서 일정 시간을 기다리고** 연결을 조료한다
- 마지막 ACK 세그먼트의 유실 대비
- 또 다른 연결 과정에서의 패킷 혼선 방지

**TCP 상태 확인**

TCP는 신뢰성 프로토콜
- 무엇인가를 확실히 전송했다는 보장이 있으려면?
  → 재전송 기반의 오류 제어 : 잘못 전송된 경우 재전송<br>
  → 흐름 제어 : 받을 수 있을 만큼만 받기<br>
  → 혼잡 제어 : 보낼 수 있는 상황에서만 보내기

- 언제 잘못 되었음을 인지할까?
    1. 중복된 ACK 세그먼트를 수신했을 때
    2. 타임아웃이 발생했을 때

TCP 오류 제어
- TCP는 재전송 기반의 오류 제어를 수행
- 재전송을 기반으로 잘못된 전송을 바로 잡는 것 : **ARQ (자동 재전송 요구)**

ARQ
- Stop-and-Wait ARQ
- Go-Back-N ARQ
- Selective Repeat ARQ

1. Stop-and-Wait ARQ
- 가장 단순한 형태
- 제대로 보냈음을 확인하고 전까지는 보내지 않음
- 전송하고, 확인하고, 전송하고, 확인하고, …

- 네트워크 이용 효율이 낮아지는 문제
이런 문제를 해결하려면?<br>
여러 세그먼트 한 번에 전송 == 파이프라이닝

2. Go-Back-N ARQ
- 올바른 세그먼트에 대해서는 확인 응답 보냄
- 올바르지 않은 세그먼트(e.g. N번 세그먼트)가 수신되면 이후(N+1번 이후) 모든 세그먼트 폐기
- 누적 확인 응답 (Cumulative ACK)

3. Selective Repeat ARQ
- 올바른 세그먼트에 대해서만 확인 응답 보냄
- 각 세그먼트에 대한 확인 응답 : 개별 확인 응답

빠른 재전송 (fast retransmit)
- 빠른 재전송이 없는 경우 : 재전송 타이머가 만료되어야 비로소 재전송
- 빠른 재전송이 있는 경우 : 재전송 타이머가 만료되지 않아도 중복 세그먼트가 수신되면 재전송

TCP 흐름 제어
- 송신 버퍼와 수신 버퍼
    - 송신 버퍼 : 어플리케이션 계층에서 전송할 데이터 임시 저장
    - 수신 버퍼 : 네트워크 계층에서 수신할 데이터 임시 저장
- 송신 호스트가 수신 호스트가 처리할 수 있는 수신 버퍼보다 더 많은 데이터를 전송하면?
- 버퍼 오버플로우 : 일부 데이턱 처리되지 않을 수 있음

송신 호스트가 수신 호스트 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 것<br>
오늘날 TCP에서의 흐름 제어 → 슬라이딩 윈도우(sliding window)
- 윈도우 : 파이프라이닝 가능한 순서번호 범위
- 윈도우 크기 : 확인 응답 받지 않고도 한번에 노낼 수 있는 최대 양

- (수신) 윈도루 크기 : TCP 헤더를 통해 송신지에게 알려주는 정보

수신 호스트
- 수신 위도우 = 수신 버퍼 크기 - [마지막으로 수신한 바이트 - 마지막으로 읽어들인 바이트]

송신 호스트
- 수신 위도우 >= 마지막으로 송신한 바이트 - 마지막으로 수신 확인된 바이트

TCP 혼잡 제어
- 혼잡 (congestion)
- 많은 트래픽으로 인해 패킷 처리 속도가 느려지거나 유실될 우려가 있는 상황
- 혼잡 제어가 이루어지지 않는다면?

혼잡 → 유실 → 재전송 → 혼잡 → 유실 → 재전송 → …

- 혼잡이 생기지 않을 정도로만 조금씩 전송하는 방법
- 혼잡 윈도우 : 혼잡 없이 전송할 수 있을 법한 양
- 송신 호스트

**최소값**(수신 윈도우, **혼잡 윈도우**) ≥ 마지막으로 송신한 바이트 - 마지막으로 수신 확인된 바이트

- 기본 동작 형태 : AIMD (Additive Increase Multicative Decrease)

배경 지식 : RTT (Round Trip Time)
- 메세지를 전송한 뒤 그에 대한 답변을 받는 시간

- 느린 시작
ACK 세그먼트가 수신될 때마다 혼잡 윈도우 1 증가 (RTT마다 혼잡 윈도우 2배 증가)

특정 임계치(sshresh)값과 같아지면 혼잡 회피 수행
- 혼잡 회피
매 RTT마다 혼잡 윈도우 1씩 증가

세 번의 중복 세그먼트가 발생했을 경우 빠른 회복 수행

- 빠른 회복
세 번의 중복 ACK 세그먼트가 수신되었을 때 느린 시작을 건너뛰고 혼잡 회피를 수행하는 알고리즘
TCP Tahoe (빠른 회복 미수행) vs TCP Reno (빠른 회복 수행)

TCP 혼잡 제어 알고리즘