## Ch 5. 가상 메모리 관리

### 페이징과 페이지 테이블
스와핑(swapping)
- 프로세스를 보조기억장치의 일부 영역으로 쫓아내고 당장 필요한 프로세스를 적재하는 메모리 관리 기법

스왑 아웃(swap-out)
- 프로세스를 보조기억장치의 일부 영역으로 쫓아내는 것

스왑 인(swap-in)
- 스왑 아웃된 프로세스를 메모리에 적재하는 것

스왑 영역
- 스왑 아웃된 프로세스가 적재되는 보조기억장치 영역

연속 메모리 할당 : 프로세스를 메모리에 연속적으로 배치하는 방식
연속 메모리 할당의 부작용 : 외부 단편화
- 프로세스 B, D 실행 종료, 남아있는 공간은 50MB
- 그런데, 남은 공간에 50MB 프로세스를 적재할 수 있을까?
- 프로세스들이 실행되고 종료되길 반복하며 빈 공간이 생기는 메모리 낭비 현상

페이징
- 물리 메모리를 프레임(frame)이라는 일정한 크기로 나누고
- 프로세스를 페이지(page)라는 일정한 크기로 나눈 뒤
- 페이지를 프레임에 매핑하는 메모리 관리 방식
- 페이지 아웃, 페이지 인

가상 메모리(virtual memory)
- 프로세스의 일부만을 적재하여 실제 물리 메모리보다 큰 프로세스를 실행하는 기술
- 페이징은 현대 운영체제에서 가장 대중적으로 사용되는 가상 메모리 관리 기법

페이지 테이블
- 프레임과 페이지의 매핑 정보를 담고 있는 표 형태의 데이터
- 프로세스마다 페이지 테이블을 가지고 있다

페이지 테이블 베이스 레지스터(PTBR)
- 각 프로세스의 페이지 테이블 위치를 가리키는 레지스터

TLB(Translation Look-aside Buffer)
- 페이지 테이블의 캐시 메모리

페이지 테이블 내 정보 : **유효 비트(valid bit)**
- 접근하려는 페이지가 보조기억장치에 있는가? 메모리에 있는가?
- 접근하려는 페이지가 보조기억장치에 있는 경우 : 페이지 폴트(page fault)
    1. 작업 내역 백업
    2. 페이지 폴트 루틴 실행 - 접근하려는 페이지 적재
    3. 유효 비트 1로 변경
    4. 접근하려는 페이지 접근

페이지 테이블 내 정보 : **보호 비트(protection bit)**
- 접근하려는 페이지의 권한

페이지 테이블 내 정보 : **참조 비트(reference bit)**
- 접근한 적 있는 페이지인가?

페이지 테이블 내 정보 : **수정 비트(modify bit / dirty bit)**
- 쓰기 작업을 한 적 있는 페이지인가?
- 
계층적 페이징 : 페이지 테이블 크기 줄이기

### 요구 페이징, 스래싱
요구 페이징
- 처음부터 모든 페이지를 적재하지 않고, 페이지 폴트가 발생하면 그 때 페이지를 적재

순수 요구 페이징
- 아무 페이지를 적재하지 않은 채 실행
- 첫 명령어 실행부터 페이지 폴트 발생
- 적당한 페이지가 적재된 이후부터 페이지 폴트 감소

페이지 폴트는 적게 발생할수록 좋다<br>
페이지 폴트를 적게 발생시키려면?
- 사실 물리 메모리가 크면 근본적으로 해결
    - 프레임이 무한히 많은 메모리의 경우 ← 무한히 많은 페이지 적재 가능
    - 프레임이 한 개 있는 메모리의 경우 ← 페이지 접근할 때마다 페이지 폴트

스래싱
- 프로세스 실행 시간보다 페이징에 더 많은 시간이 소요되는 문제
- 지나친 페이지 폴트로 인해 페이지 교체에 너무 많은 시간을 소요하여 성능이 저하되는 문제

> 동시 실행되는 프로세스 수를 늘린다고 해서 반드시 CPU 이용률이 비례하여 높아지는 것은 아닌 이유

페이지 교체 알고리즘 = 보조기억장치로 내보낼 페이지 혹은 메모리에 적재할 페이즈를 잘 선별하면 된다

### 페이지 교체 알고리즘
페이지 교체 알고리즘
- 메모리에 적재된 페이지 중 페이지-아웃시킬 페이지를 선정하는 방법
- 좋은 페이지 교체 알고리즘은 페이지 폴트를 적게 일으키는 알고리즘

종류
- FIFO 페이지 교체 알고리즘
    - 가장 먼저 메모리에 적재된 페이지부터 페이지-아웃
        - 문제 : 초기에 적재된 페이지 중 프로그램 실행 내내 유지할 데이터가 있을 수 있다
- 2차 기회 FIFO 페이지 교체 알고리즘
    - FIFO 페이지 교체 알고리즘의 변형
        - 기본적으로 가장 오래 메모리에 머물렀던 페이지부터 페이지-아웃
        - 다만 참조 비트가 1일 경우, 이를 0으로 변경 후 한번 더 기회 부여
        - 참조 비트가 0일 경우 페이지 아웃
- 최적 페이지 교체 알고리즘
    - 단순하게 생각했을 때, 메모리에서 페이지-아웃되어야 할 페이지는 **앞으로 쓸 일이 잘 없는 페이지!**
    - 앞으로의 사용 빈도가 가장 낮은 페이지부터 교체하는 알고리즘
    - 가장 낮은 페이지 폴트 빈도율을 보장하는 알고리즘
        - 하지만 앞으로 CPU가 어떤 페이지를 얼마나 참조할 지 예측하기란 매우 어려움 (timestamp)
        - 이론적으로 페이지 교체 알고리즘의 성능을 평가할 때 주로 사용되는 알고리즘
- LRU 페이지 교체 알고리즘
    - 가장 적게 참조할 페이지는 예측하기 어려워도 가장 적게 참조한 페이지는 계산하기 쉽다
    - 최근에 사용되지 않은 페이지를 페이지-아웃

### 쓰기 시 복사(copy on write)
프로세스를 fork하면 동일한 프로세스 두 개가 메모리에 복제된다<br>
그 이유는 프로세스끼리는 기본적으로 자원을 공유하지 않기 때문이다

쓰기시 복사 기법
- 복제 프로세스를 생성할 경우 이를 중복 저장하지 않고
- 동시에 프로세스 간의 자원을 공유하지 않게끔 하는 방법