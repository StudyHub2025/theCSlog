## Ch 3. CPU 스케줄링

### 프로세스 우선순위와 스케줄링 큐
운영체제가 공정하고 합리적으로 **자원(CPU, Disk)**을 배분하는 방법 = 스케줄링<br>
운영체제가 공정하고 합리적으로 **CPU**를 배분하는 방법 = CPU 스케줄링

프로세스 유형<br>
I/O bound process(I/O burst) > CPU bound process(CPU burst)

CPU 스케줄링 알고리즘 : 프로세스 우선순위를 토대로 CPU 할당 받는 방법<br>
스케줄링 큐 = 줄
> 운영체제가 관리하는 스케줄링 **큐**는 반드시 FIFO일 필요는 없다
- 준비 큐 : CPU 이용을 기다리는 프로세스들의 큐
- 대기 큐 : 대기 상태 프로세스들의 큐 (입출력 요청)

준비상태 >디스패치> 실행상태 >타임아웃> 준비상태<br>
준비상태 >디스패치> 실행상태 >IO 요청> 대기상태 >IO 완료> 준비상태

선점형 스케줄링과 비선점혐 스케줄링
1. 선점형 스케줄링 (타임아웃 기반 문맥 교환) - 현재 실행 중인 프로세스의 자원을 빼앗아 해당 프로세스에게 할당
    1. 프로세스에 자원을 고루 할당 가능
    2. 문맥 교환 과정의 오버헤드
2. 비선점형 스케줄링 - 현재 실행 중인 프로세스 실행이 끝날 때까지 해당 프로세스 대기
    1. 고르지 않은 자원 분배
    2. 문맥 교환 과정에서의 오버헤드 적음

### CPU 스케줄링 알고리즘
전공서 기준 CPU 스케줄링 알고리즘
1. 선입 선처리 스케줄링 (FIFO/FCFS 스케줄링)
    1. CPU를 먼저 요청한 프로세스부터 CPU 할당
    2. 준비 큐에 삽입된 순서대로 실행되는 비선점형 스케줄링
    - 부작용 : 호위 효과 (convoy effect)
      - 실행시간이 짧더라도, 앞에 모든 프로세스의 실행시간을 기다려야 함
2. 최단 작업 우선 스케줄링 (SJF 스케줄링)
    1. 준비 큐 프로세스 중 CPU 이용 시간이 짧은 프로세스부터 실행
    2. 호위효과 방지
3. 라운드 로빈 스케줄링 (Round Robin/RR 스케줄링)
    1. 선입 선처리 스케줄링 + 타임 슬라이스(정해져있는 시간)
    2. 준비 큐에 삽입된 순서로 실행하되, 타임 슬라이스만큼 실행
    3. 선점형 스케줄링
4. 최소 잔여 시간 우선 스케줄링 (SRT 스케줄링)
    1. 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
    2. 작업 시간 짧은 프로세스부터 처리하되, 타임 슬라이스만큼 돌아가며
5. 우선순위 스케줄링
    1. 프로세스마다 우선순위 부여, 우선순위 높은 순으로 스케줄링
    2. 최단 작업 우선 스케줄링 - 작업 시간 짧은 순으로 우선순위 부여
    3. 최소 잔여 시간 스케줄링 - 남은 시간 짧은 순으로 우선순위 부여
    - 부작용 : 아사(starvation) 현상
        - 모든 우선순위 스케줄링 알고리즘의 근본적인 문제
        - 우선순위 낮은 프로세스의 실행이 계속 연기되는 현상
        - 우선순위 높은 프로세스 실행하느라 우선순위 낮은 프로세스 실행을 못한다
        - 해결책 : 에이징(aging)
            - 대기 시간이 걸어지면 점차 우선순위를 높이는 방식
6. 다단계 큐 스케줄링
    1. 우선순위 별로 준비 큐를 여러 개 사용하는 스케줄링
        1. 우선순위가 높은 프로세스 처리
        2. 다음으로 우선순위 높은 프로세스 처리
        3. 다음으로 우선순위 높은 프로세스 처리
        4. …
    2. 장점 : 프로세스 유형 별로 큐 구분 가능
        1. e.g.) CPU 바운드, I/O 바운드, 백그라운드, 포그라운드, 실시간 프로세스…
    3. 장점 : 큐 별로 다른 스케줄링 알고리즘 적용 가능
        1. e.g.) 선입 선처리 큐, 라운드 로빈 큐, …
    4. 장점 : 큐 별로 다른 타임 슬라이스 적용 가능
    5. 단점 : 기본적으로 프로세스는 큐 간의 이동 불가능 = 아사 현상 발생
7. 다단계 피드백 큐 스케줄링
    1. 프로스세가 큐 간의 이동 가능 = 아사 현상 방지
    2. 높은 우선순위 큐에 삽입, 실행이 끝나지 않을 경우 낮은 우선순위 큐에 삽입
    3. 에이징 적용
    4. CPU bound, I/O bound 프로세스 구분 가능

### 리눅스 스케줄링
리눅스 스케줄링 정책<br>

실시간 정책 스케줄링 (우선순위 높음) - 정해진 시간(데드라인) 동안 반드시 실행이 완료되어야 함
- **SCHED_FIFO**
- **SCHED_RR**

일반 정책 스케줄링 (우선순위 낮음)
- **SCHED_OTHER/SCHED_NORMAL**
- SCHED_BATCH
- SCHED_IDLE

### CFS (Completely Fair Scheduler)
비실시간 프로세스를 대상으로 하는 스케줄링 방식 (linux kernel 2.6.23~)

**vruntime (virtual runtime)**
- 프로세스가 그동안 실행한 시간을 정규화한 정보
- vruntime이 작은 프로세스를 다음 실행할 프로세스로 삼음
- (vruntime 별 태스크를 고르는 과정에서 PB tree 사용)

**타임 슬라이스**
- nice 값에 비례해 가중치 할당, 가중치를 바탕으로 타임 슬라이스 할당

nice : 사용자 영역에서 설정한 프로세스 우선순위
- 사용자 영역에서의 값은 -20~19
- 커널 영역에서의 값은 0~139<br>
  →  실시간 스케줄링되는 프로세스 : 0~99<br>
  → CFS 프로세스 : 100~139

nice 명령어 : 새 프로세스를 실행할 때 해당 프로세스의 우선순위 부여(기본적으로 설정된 nice 값은 0)<br>
renice 명령어 : 이미 실행 중인 프로세스의 우선순위 부여


## Ch 4. 동기화와 교착상태

### 프로세스 동기화

동기화의 의미
1. 실행 순서 제어 : 프로세스를 올바른 순서로 실행하기
2. 상호 배제 : 동시에 접근해서는 안되는 지원에 하나만 접근하기

공유 자원과 임계 구역
- 공유 자원 : 공동의 자원 (e.g. 파일, 전역 변수, 입출력장치, …)
- 임계 구역 : 동시에 접근하면 문제가 발생할 수 있는 공유 자원에 접근하는 코드

레이스 컨디션(race condition)
- 임계 구역을 동시에 실행하여 자원의 일관성이 깨지는 현상

### 뮤텍스와 세마포어

동기화 해결의 세 가지 원칙
1. 상호 배제 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 대기해야 함
2. 진행 : 어떤 프로세스도 임계 구역에 진입하지 않았다면 진입이 가능해야 함
3. 유한 대기 : 한 프로세스가 임계 구역 진입을 위해 대기하고 있다면 언젠간 진입이 가능해야 함

뮤텍스 락(Mutex Lock) : 상호 배제를 위한 동기화 도구
- 자물쇠 역할 : 프로세스들이 공유하는 전역변수 lock
- 자물쇠 잠그기 : acquire 함수 - 바쁜 대기 (busy waiting)
- 자물쇠 열기 : release 함수

세마포(semaphore) : 상호 배제 & 실행 순서 제어를 위한 동기화 도구
- 뮤텍스 락은 기본적으로 공유 자원이 하나일 경우 상징
- 세마포는 공유 자원이 여러 개 있을 경우도 동기화(실행 순서 제어, 상호 배제 동기화) 가능
- 가라는 신호를 받으면 (임계 구역에) 진입해도 좋다
- 멈추라는 신호를 받으면 (임계 구역에) 진입해서는 안된다
1. 변수 S : 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)
2. wait 함수 : 임계구역에 들어가도 좋은지, 기다려야 할지를 알려주는 함수
3. signal 함수 : 임계구역 앞에서 기다리는 프로세스에게 ‘이제 가도 좋다’고 신호를 주는 함수

프로세스 상태 전이 활용

- 실행 순서를 위한 동기화
- 먼저 실행할 프로세스 뒤에 signal
- 나중에 실행할 프로세스 앞에 wait

### 조건변수와 모니터

사용이 간편한 동기화 도구, 모니터(monitor)
- 공유 자원에 접근하기 위한 인터페이스
- 인터페이스를 통해서만 접근 (상호 배제)
- 실행 순서 제어를 위한 동기화를 위해 조건 변수 사용
- 프로세스 상태 전이가 가능한 특별한 변수
    - wait() : 호줄한 프로세스를 대기 상태로 전환
    - signal() : 호출한 프로세스를 깨움

조건 변수를 활용한 실행 순서 제어
1. 아직 실행될 조건이 되지 않았을 때에는 wati을 통해 실행 중단
2. 실행될 조건이 충족되었을 때에는 signal을 통해 실행 재개

### 교착상태와 해결 방법

식사하는 철학자 문제
- 교착상태의 발생 조건 및 해결 방법을 위한 모델
- N명의 철학자, 두 개의 포크로 먹을 수 있는 음식, 원형 테이블
    - 서로의 포크를 계속 바라만 볼 뿐
    - 철학자 = 프로세스(혹은 스레드)
    - 포크 = 실행(식사)을 위해 필요한 자원

교착 상태(deadlock) : 일어나지 않을 사건(필요한 자원의 할당)을 기다리며 무한히 대기하는 현상

교착 상태 발생 조건
1. 상호 배제 : 동시에 자원 사용이 불가능한 경우
    1. 상호 배제 조건 없애기
        1. 자원을 공유 가능하도록 변경
        2. 모든 자원에 대해 적용할 수 없음
2. 점유와 대기 : 자원을 할당받은 채 다른 자원의 할당을 기다리는 경우
    1. 점유와 대기 조건 없애기
        1. 특정 프로세스에 자원을 모두 할당, 아예 할당하지 않기
        2. 자원의 활용률 저하
3. 비선점 : 강제로 자원을 빼앗을 수 없는 경우
    1. 비선점 조건 없애기
        1. 선점하여 사용 가능한 자원에 대해서는 효과적 (e.g. CPU)
        2. 모든 자원에 대해 적용 가능한 것은 아님 (e.g. 프린터기)
4. 원형 대기 : 자원을 원형으로 대기할 경우
    1. 원형 대기 조건 없애기
        1. 자원에 번호 매기기
        2. 오름차순으로 자원 할당

- 교착 상태 예방
    - 교착 상태 발생 조건 네 가지 중 하나를 없애는 것
    - 교착 상태가 발생 배경 원천 차단
    - 교착 상태가 발생하지 않음을 보장할 수 있지만, 여러 부작용이 따르는 방식
- 교착 상태 회피
    - 교착 상태가 발생하는 이유를 자원의 무분별한 할당으로 간주
        - 포크가 무한한 상황에서 한 두개의 자원만을 요구했다면?
        - 포크가 두 개 있는 상황에서 여러 개의 자원을 요구했다면?
    - 은행원 알고리즘(banker’s algorithm) - 이를 판단하는 알고리즘
- 교착 상태 검출 후 회복
    - 교착 상태가 발생하면 그때 회복하는 방식
        - 선점을 통한 회복
        - 프로세스 강제 종료를 통한 회복
    - 타조 알고리즘 - 실은 무시할 수도 있다