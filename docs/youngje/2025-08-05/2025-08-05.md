## Ch 3. CPU 스케줄링

### 프로세스 우선순위와 스케줄링 큐
운영체제가 공정하고 합리적으로 **자원(CPU, Disk)**을 배분하는 방법 = 스케줄링<br>
운영체제가 공정하고 합리적으로 **CPU**를 배분하는 방법 = CPU 스케줄링

프로세스 유형<br>
I/O bound process(I/O burst) > CPU bound process(CPU burst)

CPU 스케줄링 알고리즘 : 프로세스 우선순위를 토대로 CPU 할당 받는 방법<br>
스케줄링 큐 = 줄
> 운영체제가 관리하는 스케줄링 **큐**는 반드시 FIFO일 필요는 없다
- 준비 큐 : CPU 이용을 기다리는 프로세스들의 큐
- 대기 큐 : 대기 상태 프로세스들의 큐 (입출력 요청)

준비상태 >디스패치> 실행상태 >타임아웃> 준비상태<br>
준비상태 >디스패치> 실행상태 >IO 요청> 대기상태 >IO 완료> 준비상태

선점형 스케줄링과 비선점혐 스케줄링
1. 선점형 스케줄링 (타임아웃 기반 문맥 교환) - 현재 실행 중인 프로세스의 자원을 빼앗아 해당 프로세스에게 할당
    1. 프로세스에 자원을 고루 할당 가능
    2. 문맥 교환 과정의 오버헤드
2. 비선점형 스케줄링 - 현재 실행 중인 프로세스 실행이 끝날 때까지 해당 프로세스 대기
    1. 고르지 않은 자원 분배
    2. 문맥 교환 과정에서의 오버헤드 적음

### CPU 스케줄링 알고리즘
전공서 기준 CPU 스케줄링 알고리즘
1. 선입 선처리 스케줄링 (FIFO/FCFS 스케줄링)
    1. CPU를 먼저 요청한 프로세스부터 CPU 할당
    2. 준비 큐에 삽입된 순서대로 실행되는 비선점형 스케줄링
    - 부작용 : 호위 효과 (convoy effect)
      - 실행시간이 짧더라도, 앞에 모든 프로세스의 실행시간을 기다려야 함
2. 최단 작업 우선 스케줄링 (SJF 스케줄링)
    1. 준비 큐 프로세스 중 CPU 이용 시간이 짧은 프로세스부터 실행
    2. 호위효과 방지
3. 라운드 로빈 스케줄링 (Round Robin/RR 스케줄링)
    1. 선입 선처리 스케줄링 + 타임 슬라이스(정해져있는 시간)
    2. 준비 큐에 삽입된 순서로 실행하되, 타임 슬라이스만큼 실행
    3. 선점형 스케줄링
4. 최소 잔여 시간 우선 스케줄링 (SRT 스케줄링)
    1. 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
    2. 작업 시간 짧은 프로세스부터 처리하되, 타임 슬라이스만큼 돌아가며
5. 우선순위 스케줄링
    1. 프로세스마다 우선순위 부여, 우선순위 높은 순으로 스케줄링
    2. 최단 작업 우선 스케줄링 - 작업 시간 짧은 순으로 우선순위 부여
    3. 최소 잔여 시간 스케줄링 - 남은 시간 짧은 순으로 우선순위 부여
    - 부작용 : 아사(starvation) 현상
        - 모든 우선순위 스케줄링 알고리즘의 근본적인 문제
        - 우선순위 낮은 프로세스의 실행이 계속 연기되는 현상
        - 우선순위 높은 프로세스 실행하느라 우선순위 낮은 프로세스 실행을 못한다
        - 해결책 : 에이징(aging)
            - 대기 시간이 걸어지면 점차 우선순위를 높이는 방식
6. 다단계 큐 스케줄링
    1. 우선순위 별로 준비 큐를 여러 개 사용하는 스케줄링
        1. 우선순위가 높은 프로세스 처리
        2. 다음으로 우선순위 높은 프로세스 처리
        3. 다음으로 우선순위 높은 프로세스 처리
        4. …
    2. 장점 : 프로세스 유형 별로 큐 구분 가능
        1. e.g.) CPU 바운드, I/O 바운드, 백그라운드, 포그라운드, 실시간 프로세스…
    3. 장점 : 큐 별로 다른 스케줄링 알고리즘 적용 가능
        1. e.g.) 선입 선처리 큐, 라운드 로빈 큐, …
    4. 장점 : 큐 별로 다른 타임 슬라이스 적용 가능
    5. 단점 : 기본적으로 프로세스는 큐 간의 이동 불가능 = 아사 현상 발생
7. 다단계 피드백 큐 스케줄링
    1. 프로스세가 큐 간의 이동 가능 = 아사 현상 방지
    2. 높은 우선순위 큐에 삽입, 실행이 끝나지 않을 경우 낮은 우선순위 큐에 삽입
    3. 에이징 적용
    4. CPU bound, I/O bound 프로세스 구분 가능

### 리눅스 스케줄링
리눅스 스케줄링 정책<br>

실시간 정책 스케줄링 (우선순위 높음) - 정해진 시간(데드라인) 동안 반드시 실행이 완료되어야 함
- **SCHED_FIFO**
- **SCHED_RR**

일반 정책 스케줄링 (우선순위 낮음)
- **SCHED_OTHER/SCHED_NORMAL**
- SCHED_BATCH
- SCHED_IDLE

### CFS (Completely Fair Scheduler)
비실시간 프로세스를 대상으로 하는 스케줄링 방식 (linux kernel 2.6.23~)

**vruntime (virtual runtime)**
- 프로세스가 그동안 실행한 시간을 정규화한 정보
- vruntime이 작은 프로세스를 다음 실행할 프로세스로 삼음
- (vruntime 별 태스크를 고르는 과정에서 PB tree 사용)

**타임 슬라이스**
- nice 값에 비례해 가중치 할당, 가중치를 바탕으로 타임 슬라이스 할당

nice : 사용자 영역에서 설정한 프로세스 우선순위
- 사용자 영역에서의 값은 -20~19
- 커널 영역에서의 값은 0~139<br>
  →  실시간 스케줄링되는 프로세스 : 0~99<br>
  → CFS 프로세스 : 100~139

nice 명령어 : 새 프로세스를 실행할 때 해당 프로세스의 우선순위 부여(기본적으로 설정된 nice 값은 0)<br>
renice 명령어 : 이미 실행 중인 프로세스의 우선순위 부여