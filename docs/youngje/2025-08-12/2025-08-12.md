## Ch 3. 네트워크 계층

네트워크 계층
- 물리 계층과 데이터링크 계층 → LAN에 국한된 통신
- LAN을 넘어서기 위한 계층
- 네트워크 간 통신이 가능한 계층 → 라우팅
- 단편화가 이루어지는 계층

데이터링크 계층의 MAC 주소 있는데?
- 도달 경로를 파악하기 어려움 (라우딩 어려움)
- 임의의 네트워크에 속한 호스트의 MAC 주소를 기억하기 어려움

기본적으로 MAC 주소 이전에 IP 주소를 사용
- MAC 주소 = 수취인 개인 정보 (e.g. 주민등록번호) → 물리 주소
- IP 주소 = 수취인 주소 (e.g. 서울특별시 노원구 …) → 논리 주소
- 직접 할당
- 자동 할당 (DHCP, Dynamic Host Configuration Protocol)

IP의 두 가지 주요 기능
- IP 주소 지정
- 단편화

단편화
- 패킷의 크기를 MTU(Maximum Transmission Unit) 이하로 유지
- MTU 크기 이하로 단편화된 패킷들은 목적지에서 재조합

window
```bash
> netsh interface ipv4 show interfaces
```

linux
```bash
$ ifconfig
```

### IPv4

IPv4 헤더
- 송신지, 목적지 IP 주소
- 식별자, 플래그, 단편화 오프셋
    - 식별자 : 패킷에 할당된 번호 (재조합 시 사용)
    - 플래그 : 부가 정보 (미사용, Don’t Fragment[DF], More Fragment[MF] 비트)
    - 단편화 오프셋 : 단편화되거 전 데이터가 얼마나 떨어져 있는가
- TTL, 프로토콜
  - TTL(Time To Live) : 패킷의 수명, 라우터를 거칠 때마다 1감소(이후, 폐기)
  - 프로토콜 : 상위 계층의 프로토콜(무엇을 캡슐화했는가?) (e.g. TCP==6, UDP==17)

IPv4 주소
- 4바이트 (32비트)로 표현 가능
- 한 옥텟은 0~255 범위의 네 개의 십진수로 표기
- 이론적으로 할당 가능한 IPv4 주소 개수 == 2^32개 ← 넉넉한 양이 아님
- IP 주소 부족 문제 ← NAT가 고갈을 막았음

IPv6 주소
- 16바이트 (128비트)로 표현 가능
- 이론적으로 할당 가능한 IPv4 주소 개수 == 2^128개 ← 사실상 무한

> 홉 제한 = TTL = 패킷의 수명을 나타내는 필드<br>
> 다음 헤더 = 확장 헤더(Extension Header) = 추가 헤더

확장 헤더
- 확장 헤더가 존재하지 않을 경우
- 확정 헤더가 하나만 존재할 경우
- 확정 헤더가 두 개 존재할 경우


- 라우팅 확장 헤더
- 인증 확정 헤더
- 단편화 확장 헤더

### ARP
IP 주소를 통해 MAC 주소를 알아내기 위한 프로토콜
**동일 네트워크 내의 호스트**의 MAC 주소를 알아내기 위한 프로토콜

ARP 동작 과정
1. ARP 요청
2. ARP 응답
3. ARP 테이블(ARP 캐시) 갱신

1. ARP 요청 (브로드캐스트 메세지)
특정 IP 주소를 가진 호스트의 MAC 주소를 알아내기 위해 보내는 브로드캐스트 메시지
해당 호스트의 MAC 주소를 모르기 때문에 브로드캐스트 메세지로 전송
2. ARP 응답
ARP 요청 메세지에 대한 응답. 자신의 MAC 주소 포함.<br>
ARP 패킷
3. 1. ARP 테이블 갱신
- ARP 테이블(ARP 캐시) : MAC 주소와 IP 주소가 매핑된 표 형태의 데이터
- 일정 시간이 지나면 삭제 (삭제하기 위한 명령어도 있음)
- ARP 테이블에 추가된 호스트는 브로드캐스트로 ARP 요청 보낼 필요 없음

```bash
$ arp -a # ARP 테이블 전체 보기

$ arp -ad # ARP 테이블 전체 삭제
```

다른 네트워크에 속한 호스트의 MAC 주소 알아내기

IP의 한계
1. **비신뢰성** : 패킷이 목적지까지 제대로 전송한다는 보장이 없는 특성
  1. 최선형 전달(best-effort delivery) = 최선은 다해보겠지만 그 이후에 어떤 책임도 지지 않겠다
2. **비연결성** : 호스트 간의 사전 연결 수립이 없는 특성

신뢰성 프로토콜, 연결형 프로토콜을 제공하는 계층은 전송 계층 (TCP)

### ICMP

IP의 비신뢰성과 비연결형 특성을 보완하기 위한 네트워크 계층 프로토콜<br>
IP 패킷의 전송 과정에 대한 **피드백 메세지** 제공

- 오류 보고
- 네트워크 진단 정보
- ICMP 메시지는 타입과 코드로 정의

오류 보고

| 타입 이름 (타입 번호) | 코드 번호 | 코드 설명 |
| --- | --- | --- |
| 목적지 도달 불가 (3);
특정 패킷을 목적지까지 도달할 수 없음 (Destination Unreachable) | 0 | 네트워크 도달 불가 |
|  | 1 | 호스트 도달 불가 |
|  | 2 | 프로토콜 도달 불가; 목적지에서 특정 프로토콜을 사용할 수 없음 |
|  | 3 | 포트 도달 불가 |
|  | 4 | 단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음 |
| 시간 초과 (11) | 0 | TTL 초과 |

네트워크 진단 정보

| 타입 이름 (타입 번호) | 코드 번호 | 코드 설명 |
| --- | --- | --- |
| 에코 요청 (8) | 0 | 에코 요청 |
| 에코 응답 (0) | 0 | 에코 요청에 대한 응답 |
| 라우터 광고 (9) | 0 | 라우터 광고 ; 라우터가 호스트에게 자신을 알림 |

- IP의 한계를 보완할 뿐 완전히 해결하는 것은 아니다 <br>
https://www.rfc-editor.org/rfc/rfc792<br>
근본적인 해결은 전송 계층에서 이루어짐

### IP 주소
IP 주소의 구성 : 네트워크 주소, 호스트 주소 (유동적)<br>
MAC 주소의 구성 : 제조사 번호(OUI), 일련 번호(UAA) (비트 수 24/24비트 고정)

호스트 주소부 = 0 = 네트워크 주소<br>
호스트 주소부 = 1 = 브로드캐스트 주소

할당할 수 있는 호스트 개수는 전체 범위에서 2개(네트워크 주소, 브로드캐스트 주소)를 뺀 만큼만 할당 가능

클래스리스 주소체계
- 클래스풀 주소 체계보다 더 정교히 네트워크를 나누는 방법
- 오늘날 주로 사용하는 방식
- 네트워크와 호스트를 구분하기 위해 **서브넷 마스크** 이용

서브넷 마스크

- IP 주소 상에서 네트워크 주소는 1, 호스트 주소는 0으로 이루어진 비트열
- 클래스 A : 255.0.0.0(11111111.00000000.00000000.00000000)
- 클래스 B : 255.255.0.0(11111111.11111111.00000000.00000000)
- 클래스 C : 255.255.2555.0(11111111.11111111.11111111.00000000)

서브넷 마스크와 IP 주소의 비트 AND 연산 → 네트워크 주소

CIDR 표기
- 서브넷 마스크 상의 연속된 **1의 개수**를 IP주소**/숫자**로 표기
- 192.168.100.103**/30**