## 1. 지역 클래스(Local Class)

### 특징

-   **내부 클래스의 특별한 형태**
-   메서드, 생성자, 블럭 내부에 정의됨 → 지역 변수처럼 동작
-   바깥 클래스의 인스턴스 멤버 접근 가능
-   선언 위치가 지역 변수와 동일 → **접근 제어자 사용 불가**

``` java
class Outer {
    public void process() {
        int localVar = 0;

        class Local {
            public void print() {
                System.out.println("localVar=" + localVar);
            }
        }
        Local local = new Local();
        local.print();
    }
}
```

### 지역 클래스의 접근 범위

-   자신의 인스턴스 변수
-   해당 블럭의 지역 변수와 매개변수
-   바깥 클래스의 인스턴스 변수

------------------------------------------------------------------------

## 2. 지역 변수 캡처 (Variable Capture)

### 문제 상황

-   지역 변수는 메서드 실행 종료 시 스택에서 사라짐
-   지역 클래스 인스턴스는 힙에 저장되므로 더 오래 생존 가능
-   따라서 **지역 변수를 직접 참조할 수 없음**

### 해결 방법 → 캡처

-   자바는 지역 변수를 **복사**해서 인스턴스에 보관
-   복사된 변수는 `val$변수명` 필드 형태로 확인 가능
-   지역 변수는 반드시 **final** 또는 **사실상 final** 이어야 함

``` java
public Printer process(int paramVar) {
    int localVar = 1;
    class LocalPrinter implements Printer {
        public void print() {
            System.out.println(localVar);  // 실제로는 캡처된 값 참조
        }
    }
    return new LocalPrinter();
}
```

### 제약: final 또는 effectively final

``` java
int localVar = 1;
// localVar = 10; // 컴파일 오류 발생
```

-   이유: 값이 바뀌면 지역 변수와 캡처 변수 불일치 → 동기화 문제 발생

------------------------------------------------------------------------

## 3. 익명 클래스(Anonymous Class)

### 특징

-   이름 없는 지역 클래스
-   **선언 + 생성 동시에**
-   **인터페이스 구현** 또는 **부모 클래스 상속** 필요
-   이름이 없으므로 생성자 정의 불가 (기본 생성자만 가능)

``` java
Printer printer = new Printer() {
    @Override
    public void print() {
        System.out.println("익명 클래스 실행");
    }
};
printer.print();
```

출력:

    익명 클래스 실행

### 장점

-   일회성 구현체 작성에 유용
-   코드 간결성

### 단점

-   재사용 불가
-   복잡한 로직은 가독성 저하

------------------------------------------------------------------------

## 4. 활용 예제: 변하는 부분/변하지 않는 부분 분리

### 리팩토링 전

``` java
public static void helloJava() {
    System.out.println("시작");
    System.out.println("Hello Java");
    System.out.println("종료");
}
public static void helloSpring() {
    System.out.println("시작");
    System.out.println("Hello Spring");
    System.out.println("종료");
}
```

### 리팩토링 후 (데이터만 외부 전달)

``` java
public static void hello(String str) {
    System.out.println("시작");
    System.out.println(str);
    System.out.println("종료");
}
```

------------------------------------------------------------------------

## 5. 코드 조각 전달하기

### 인터페이스 + 클래스 구현

``` java
interface Process { void run(); }

static class Dice implements Process {
    public void run() {
        int val = new Random().nextInt(6) + 1;
        System.out.println("주사위=" + val);
    }
}
```

### 익명 클래스 활용

``` java
hello(new Process() {
    public void run() {
        System.out.println("주사위=" + (new Random().nextInt(6) + 1));
    }
});
```

### 람다(Lambda) (Java 8+)

``` java
hello(() -> {
    System.out.println("주사위=" + (new Random().nextInt(6) + 1));
});
```

------------------------------------------------------------------------

## 최종 정리

-   **정적 중첩 클래스**
    -   바깥 클래스와 무관
    -   `static` 붙음
    -   주로 **논리적 그룹화, 캡슐화** 용도
-   **내부 클래스**
    -   바깥 클래스 인스턴스에 소속
    -   바깥 클래스 멤버 접근 가능
-   **지역 클래스**
    -   메서드 블럭 내부에서 정의
    -   지역 변수 캡처 필요
    -   접근 변수는 `final` 또는 `effectively final`
-   **익명 클래스**
    -   이름 없는 지역 클래스
    -   인터페이스/추상 클래스 구현 시 간단하게 사용
    -   Java 8 이후는 **람다**로 대체 가능
