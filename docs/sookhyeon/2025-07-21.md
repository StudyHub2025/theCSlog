# Ch2. 명령어

## 1. 명령어의 구조와 주소 지정

- **명령어**: 컴퓨터가 수행할 작업을 지시하는 정보  
- **구성**: `명령어 = 연산 코드 (op-code) + 오퍼랜드 (operand)`
  - **op-code**: 어떤 연산을 수행할지
  - **operand**: 어떤 데이터를 대상으로 연산할지

### 오퍼랜드 표현 방식
- 직접적인 데이터
- 데이터의 위치 (레지스터, 메모리 주소 등)

### 연산 코드 유형
- **데이터 전송**: `MOVE`, `STORE`, `LOAD`, `PUSH`, `POP`
- **산술/논리 연산**: `ADD`, `SUBTRACT`, `MULTIPLY`, `AND`, `COMPARE` 등
- **제어 흐름 변경**: `JUMP`, `CALL`, `RETURN`, `HALT` 등
- **입출력 제어**: `READ`, `WRITE`, `START IO` 등

### 왜 주소를 명시하는가?
- 명령어의 길이는 제한적이므로 데이터를 직접 담기보다는 위치(주소)를 명시한다.

### 주소 지정 방식 (5가지)
| 방식                   | 설명 |
|------------------------|------|
| **즉시 주소 지정**       | 오퍼랜드 필드에 데이터 자체를 명시. 가장 빠름 |
| **직접 주소 지정**       | 오퍼랜드 필드에 데이터가 저장된 메모리 주소 명시 |
| **간접 주소 지정**       | 오퍼랜드에 유효 주소의 주소를 명시. 느리지만 유연 |
| **레지스터 주소 지정**   | 오퍼랜드에 레지스터 이름을 명시. 빠름 |
| **레지스터 간접 주소 지정** | 레지스터에 저장된 주소를 사용해 메모리 데이터에 접근 |

---

# Ch3. 데이터 (Data)

## 1. 이진수와 2의 보수
- 컴퓨터는 0과 1만 이해하며, 양수는 **이진수**, 음수는 **2의 보수**로 표현
- 이진수는 길어지므로 **16진수**로 줄여 표현
- **2의 보수**는 비트를 반전 후 1을 더하거나 `2ⁿ에서 빼는 방식`
- 부호는 **CPU의 플래그**를 통해 구분

## 2. 부동소수점 (Floating Point)
- `0.1 + 0.2 != 0.3`이 되는 이유: **근사값 저장 때문**
- **IEEE 754 표준** 사용: `m × 2ⁿ` 형태
  - 항상 `1.xxx`로 정규화
  - 지수에는 **bias** 적용
- `1/3`, `1/10` 등의 소수는 2진수로 **정확히 표현 불가** → 무한소수로 저장됨

## 3. 문자 인코딩과 디코딩
- CPU 구성:
  - **ALU**: 산술 및 논리 연산
  - **제어장치**: 명령 해석 및 제어 신호 생성
  - **레지스터**: 내부 데이터 저장
- 주요 레지스터:
  - `PC`, `IR`, `MAR`, `MBR`, `Flag`, **범용 레지스터**, **스택 포인터**, **베이스 레지스터**
- **클럭 신호**: 모든 동작을 동기화하며, 클럭 속도가 빠를수록 처리 속도 향상

---

