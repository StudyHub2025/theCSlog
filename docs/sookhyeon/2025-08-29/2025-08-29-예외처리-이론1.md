## 1. 예외 처리가 필요한 이유

### 기본 흐름

-   프로그램은 외부 환경(네트워크, DB, 파일 등)과 상호작용할 때 항상
    **실패 가능성**이 존재한다.
-   예: 네트워크 통신
    -   서버 연결 실패
    -   데이터 전송 실패
    -   연결 해제 누락

### 단순 예시

``` java
client.connect();
client.send(data);
client.disconnect();
```

**문제점** - `connect()`가 실패해도 `send()` 호출 → 잘못된 동작 - 예외
발생 시 `disconnect()` 호출 보장 X → 자원 누수 가능 - 반환값으로 오류
코드를 확인해야 하는 구조 → 정상 흐름과 예외 흐름이 섞여서 복잡해짐

------------------------------------------------------------------------

## 2. 오류 상황 시뮬레이션

### 반환값 기반 오류 처리

``` java
String connectResult = client.connect();
if (isError(connectResult)) {
    System.out.println("네트워크 오류 발생");
    return;
}
```

-   `connect()` / `send()`의 결과를 매번 확인해야 함
-   `disconnect()` 호출을 보장하기 어려움
-   **정상 코드와 예외 코드가 뒤섞여 가독성 저하**

### 개선 필요성

-   정상 흐름은 단순해야 함
-   예외 흐름은 별도로 분리되어야 함

------------------------------------------------------------------------

## 3. 자바 예외 처리 개념

자바는 예외 상황을 처리하기 위해 **예외(Exception) 객체와 키워드**를
제공한다.

### 주요 키워드

-   `try` : 예외 발생 가능성이 있는 코드 블럭
-   `catch` : 예외 처리 블럭
-   `finally` : 무조건 실행되는 블럭 (자원 정리용)
-   `throw` : 예외 발생
-   `throws` : 메서드가 예외를 던진다는 선언

------------------------------------------------------------------------

## 4. 예외 계층 구조

    Object
     └── Throwable
          ├── Error
          └── Exception
               ├── (Checked Exception)
               └── RuntimeException (Unchecked Exception)

### 설명

-   **Throwable**
    -   자바의 최상위 예외 타입
-   **Error**
    -   시스템 레벨 오류 (OutOfMemoryError 등)
    -   복구 불가능 → 애플리케이션에서 처리 X
-   **Exception**
    -   애플리케이션 로직에서 사용되는 예외
    -   컴파일러가 체크하는 **체크 예외**
-   **RuntimeException**
    -   실행 중 발생하는 예외
    -   **언체크 예외 (Unchecked Exception)**
    -   `NullPointerException`, `ArrayIndexOutOfBoundsException` 등

------------------------------------------------------------------------

## 5. 예외 처리 기본 규칙

1.  예외는 **잡아서 처리**하거나 **밖으로 던져야 한다**.
2.  상위 타입으로 선언하면 하위 타입까지 모두 처리 가능하다.

### 흐름 예시

1.  `Client`에서 예외 발생
2.  `Client`에서 처리하지 않으면 `Service`로 던짐
3.  `Service`에서 처리하지 않으면 `Main`으로 던짐
4.  `Main`까지 처리하지 않으면 프로그램 종료

------------------------------------------------------------------------

## 6. 체크 예외 (Checked Exception)

### 정의

-   `Exception`을 상속 (단, `RuntimeException` 제외)
-   컴파일러가 **반드시 처리 강제**
-   처리하지 않으면 **컴파일 에러 발생**

### 예시

``` java
class MyCheckedException extends Exception {
    public MyCheckedException(String msg) {
        super(msg);
    }
}

public void call() throws MyCheckedException {
    throw new MyCheckedException("에러 발생");
}
```

-   `throw` : 실제 예외 발생
-   `throws` : 메서드 선언부에 예외를 던진다고 명시

### 장단점

-   장점: 개발자가 실수로 예외를 누락하지 않도록 강제
-   단점: 모든 예외를 잡거나 던져야 해서 코드가 번거로움

------------------------------------------------------------------------

## 7. 언체크 예외 (Unchecked Exception)

### 정의

-   `RuntimeException` 상속
-   컴파일러가 체크하지 않음
-   `throws` 선언 불필요

### 예시

``` java
class MyUncheckedException extends RuntimeException {
    public MyUncheckedException(String msg) {
        super(msg);
    }
}

public void call() {
    throw new MyUncheckedException("에러 발생");
}
```

### 특징

-   잡지 않아도 호출 스택을 타고 올라가면서 전파됨
-   원할 경우 `try-catch`로 잡을 수 있음
-   보통 **개발자 실수**를 표현할 때 사용

### 장단점

-   장점: 코드 단순화, 불필요한 선언 제거
-   단점: 예외 누락 가능성

------------------------------------------------------------------------

## 8. 체크 예외 vs 언체크 예외 비교

구분            체크 예외 (Checked)         언체크 예외 (Unchecked)
  --------------- --------------------------- --------------------------------
상속            `Exception`                 `RuntimeException`
컴파일러 체크   O (필수 처리)               X
`throws` 선언   필수                        선택
사용 예         IO, SQL 등 외부 자원 오류   NPE, Index 오류 등 개발자 실수
장점            안정성 확보                 코드 단순화
단점            코드 번거로움               예외 누락 가능

------------------------------------------------------------------------

## 정리

-   반환값 기반 오류 처리 → 정상/예외 흐름이 섞여 가독성 저하
-   자바 예외 처리 → 예외 흐름을 별도 처리하여 가독성과 안정성 확보
-   **체크 예외**: 반드시 처리, 안정성 높음 (IO, DB 관련)
-   **언체크 예외**: 처리 강제 없음, 주로 프로그래밍 오류 (NPE,
    IllegalArgumentException)
