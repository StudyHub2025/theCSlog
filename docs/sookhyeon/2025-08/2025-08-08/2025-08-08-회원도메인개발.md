# 회원 도메인 개발

## 1. 회원 리포지토리 개발

### 코드
```java
@Repository
public class MemberRepository {

    @PersistenceContext
    private EntityManager em;

    // 회원 저장
    public void save(Member member) {
        em.persist(member);
    }

    // 단건 조회
    public Member findOne(Long id) {
        return em.find(Member.class, id);
    }

    // 전체 조회
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }

    // 이름으로 조회
    public List<Member> findByName(String name) {
        return em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
    }
}
```

### 어노테이션 
- **`@Repository`**
    - Spring 컴포넌트 스캔 대상
    - JPA 예외 → Spring 데이터 접근 예외(`DataAccessException`) 변환
- **`@PersistenceContext`**
    - JPA 표준 어노테이션
    - `EntityManager`를 주입받음
- **`@PersistenceUnit`**
    - `EntityManagerFactory` 주입 시 사용

### 기능 
- `save()` : 회원 저장 (영속성 컨텍스트에 등록)
- `findOne()` : PK 기반 단건 조회
- `findAll()` : JPQL로 전체 회원 목록 조회
- `findByName()` : JPQL + 파라미터 바인딩으로 이름 기반 조회

---

## 2. 회원 서비스 개발

### 코드
```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class MemberService {

    private final MemberRepository memberRepository;
    
    @Transactional // 쓰기 작업
    public Long join(Member member) {
        validateDuplicateMember(member); // 중복 회원 검증
        memberRepository.save(member);
        return member.getId();
    }

    // 중복 회원 검증
    private void validateDuplicateMember(Member member) {
        List<Member> findMembers = memberRepository.findByName(member.getName());
        if (!findMembers.isEmpty()) {
            throw new IllegalStateException("이미 존재하는 회원입니다.");
        }
    }
    
    public List<Member> findMembers() {
        return memberRepository.findAll();
    }
    
    public Member findOne(Long memberId) {
        return memberRepository.findOne(memberId);
    }
}
```

### 어노테이션
- **`@Service`**
    - 서비스 계층 선언, Spring 빈 등록
- **`@Transactional`**
    - 트랜잭션 경계 설정
    - `readOnly = true` → 읽기 전용 (플러시 X, 성능 최적화)
    - 데이터 변경이 필요한 메서드는 `readOnly = false` 또는 속성 제거
- **`@Autowired`** / **`@RequiredArgsConstructor`**
    - 생성자 주입 사용 권장 (불변성 확보, 테스트 용이)
    - 생성자가 하나면 `@Autowired` 생략 가능
- **중복 회원 검증**
    - 로직에서 검증하더라도 **DB 유니크 제약 조건** 추가 권장 (멀티스레드 안전성)

---

## 3. 회원 기능 테스트

### 테스트 요구사항
1. 회원가입을 성공해야 한다.
2. 같은 이름이 있으면 예외가 발생해야 한다.

### 테스트 코드
```java
@SpringBootTest
@Transactional
public class MemberServiceTest {

    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;

    @Test
    public void 회원가입() throws Exception {
        // Given
        Member member = new Member();
        member.setName("kim");

        // When
        Long saveId = memberService.join(member);

        // Then
        assertEquals(member, memberRepository.findOne(saveId));
    }

    @Test
    public void 중복_회원_예외() throws Exception {
        // Given
        Member member1 = new Member();
        member1.setName("kim");

        Member member2 = new Member();
        member2.setName("kim");

        // When
        memberService.join(member1);
        memberService.join(member2); // 예외 발생해야 함

        // Then
        fail("예외가 발생해야 한다.");
    }
}
```

### 어노테이션
- **`@SpringBootTest`**
    - 스프링 부트를 띄우고 전체 컨텍스트 로드 (빈 주입 가능)
- **`@Transactional`**
    - 테스트 케이스에서 사용 시 각 테스트 후 자동 롤백
    - 반복 실행 가능한 테스트 환경 제공

---

## 4. 테스트 환경 설정

- 테스트는 격리된 환경에서 실행 후 데이터 초기화가 필요
- 메모리 DB(H2)를 사용하면 이상적
- `test/resources/application.yml` 예시:
```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: create
    properties:
      hibernate:
        format_sql: true
  logging.level:
    org.hibernate.SQL: debug
```
- 설정 파일이 `test/resources`에 있으면 테스트 실행 시 우선 읽힘
- Spring Boot는 datasource 설정이 없으면 자동으로 **메모리 DB + create-drop** 모드 사용

---

## 7. 참고 사항

- 테스트 작성 시 **Given / When / Then** 패턴 활용 권장
    - 가독성 및 유지보수성 향상
    - 예: [마틴 파울러 블로그](http://martinfowler.com/bliki/GivenWhenThen.html)
- 실무에서는 **유효성 검증 로직 + DB 제약 조건**을 함께 두는 것이 안전
- 서비스 계층에서 **필드 주입 대신 생성자 주입** 사용 권장
    - 불변성 유지 (`final`)
    - 컴파일 시점에 누락 의존성 확인 가능
- Lombok `@RequiredArgsConstructor`를 활용하면 생성자 주입 보일러플레이트 제거 가능
