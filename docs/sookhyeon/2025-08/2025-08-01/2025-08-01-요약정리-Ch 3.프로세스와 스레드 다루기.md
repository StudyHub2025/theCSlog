# Ch3. 프로세스와 스레드 다루기 

---

## Ch3-1. 프로세스 다루기

### 프로세스 개념
- 실행 중인 프로그램을 의미하며 고유한 **PID**를 갖는다.
- 프로세스 간 자원은 **독립적**이다.
- 포그라운드 / 백그라운드 프로세스 구분 가능

### 프로세스 제어 블록 (PCB)
- 프로세스 상태, 레지스터, 스케줄링 정보, 메모리 정보, 파일/입출력 정보 등 포함

### 프로세스 상태
- `R` (Running), `S` (Sleeping), `W` (Waiting), `Z` (Zombie) 등
- `top`, `ps` 명령어로 상태 확인 가능

### 프로세스 생성: `fork()`
- 자식 프로세스를 생성. 부모는 자식 PID, 자식은 0 반환
- 실패시 -1 반환
- `getpid()`, `getppid()`로 PID 확인 가능

### 실행 코드 교체: `exec()` family
- `execl`, `execv`, `execvp`, `execle`, `execve`
- 기존 프로세스를 새로운 프로그램으로 덮어씀

### 프로세스 종료: `exit(status)`
- 정상 종료: 0, 비정상 종료: 기타 숫자
- 부모가 자식 종료 처리 안하면 좀비 프로세스(Zombie)

### 자식 종료 처리: `wait()`, `waitpid()`
- 자식 프로세스 종료 대기 및 상태 회수

---

## Ch3-2. 스레드 다루기

### 스레드 개념
- 하나의 프로세스 내에서 실행되는 흐름의 단위
- 동일한 주소 공간과 자원 공유
- 각 스레드는 ID, PC, 레지스터, 스택은 독립적으로 가짐

### 장단점 비교
| 항목       | 프로세스 | 스레드 |
|------------|----------|--------|
| 자원 공유 | 없음     | 있음   |
| 생성 비용 | 큼       | 작음   |
| 독립성    | 높음     | 낮음   |

### 스레드 생성: `pthread_create()`
```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine)(void*), void *arg);
```

### 스레드 종료
- `pthread_exit()`로 명시 종료
- `pthread_join()`으로 종료 대기 및 결과 수거
- `pthread_detach()`로 자원 자동 반환

---

## Ch3-3. 뮤텍스와 세마포

### 임계구역 문제
- 공유 자원에 대한 동시 접근 방지 필요

### 뮤텍스 (Mutual Exclusion)
- `pthread_mutex_init()`, `lock()`, `unlock()`, `destroy()` 등 사용
- **trylock()**: 락을 기다리지 않고 즉시 반환

### 세마포어
- 값이 0이면 대기, 양수면 자원 사용 가능
- Unnamed: `sem_init`, Named: `sem_open` 등
- `sem_wait()`, `sem_post()`로 자원 요청/해제

---

## Ch3-4. 공유 메모리 기반 IPC

### 공유 메모리란?
- 여러 프로세스가 **공통으로 접근 가능한 메모리**
- 속도가 빠르지만 동기화가 필요

### 주요 함수
```c
shm_open() / ftruncate() / mmap() / munmap() / shm_unlink()
```

### 예시 흐름
1. `shm_open()`으로 공유 메모리 파일 디스크립터 생성
2. `ftruncate()`로 크기 설정
3. `mmap()`으로 메모리에 매핑
4. 읽기/쓰기 후 `munmap()`, `shm_unlink()`로 정리

---

## Ch3-5. 파이프 기반 IPC

### pipe 개념
- 단방향 통신을 위한 파일 기반 IPC 도구
- 부모-자식 간 통신 등에서 사용됨

### 기본 함수
```c
pipe(int pipefd[2])     // 생성
read(pipefd[0], ...)    // 읽기
write(pipefd[1], ...)   // 쓰기
close(fd)               // 닫기
```

### Named Pipe (FIFO)
- `mkfifo()`로 파일 경로에 생성
- `open()`, `read()`, `write()` 사용

---

## Ch3-6. 시그널 다루기

### 시그널이란?
- **프로세스에게 발생한 이벤트를 알리는 인터럽트**
- `SIGINT`, `SIGKILL`, `SIGTERM`, `SIGCHLD` 등

### 시그널 전송
```c
kill(pid, signal);     // 외부 시그널 전송
raise(signal);         // 자기 자신에게 시그널
```

### 시그널 처리
```c
signal(SIGINT, handler_func);  // 단순 handler 지정
sigaction()                    // 고급 처리 가능
```

### 마스킹 (차단)
- `sigset_t`, `sigemptyset()`, `sigaddset()` 등 사용
- 특정 시그널을 일시적으로 차단하거나 대체 처리 가능

---

### 예제 코드 위치
- `sys/process_1.c ~ process_6.c`
- `sys/thread_1.c, thread_2.c`
- `sys/mutex_1.c`
- `sys/sem_1.c, sem_2.c`
- `sys/shmem.c`
- `sys/pipe_1.c ~ pipe_4.c`
- `sys/signalex.c, sigex2.c, sigex3.c`
