# String 클래스

## 1. 불변 String의 한계

`String`은 불변(Immutable)이므로 한 번 생성된 문자열은 변경할 수 없다.
문자열을 더하거나 수정할 때마다 **새로운 String 객체**를 생성해야 한다.

```java
"A" + "B"
// 내부 동작
new String("A").concat(new String("B"));
new String("AB"); // 새로운 객체 생성
```
- 여러 번 문자열을 변경하면 **불필요한 객체 생성** → 메모리 낭비, 성능 저하
- 특히 반복문에서 문자열 연결 시 비효율적

---

## 2. StringBuilder (가변 String)

문자열 변경을 효율적으로 하기 위해 **가변(Mutable) 문자열 클래스** `StringBuilder` 제공.

```java
public final class StringBuilder {
    char[] value; // Java 9 이전
    byte[] value; // Java 9 이후
    ...
}
```
- 내부 배열(`byte[]` 또는 `char[]`)을 변경 가능하게 두어, 객체를 새로 만들지 않고 내용 수정
- **장점**: 메모리 절약, 빠른 처리 속도
- **단점**: 불변이 아니므로 참조 공유 시 값 변경 부작용 가능

---

## 3. StringBuilder 사용 예시

```java
StringBuilder sb = new StringBuilder();
sb.append("A");
sb.append("B");
sb.append("C");
sb.append("D");
System.out.println(sb); // ABCD

sb.insert(4, "Java");
System.out.println(sb); // ABCDJava

sb.delete(4, 8);
System.out.println(sb); // ABCD

sb.reverse();
System.out.println(sb); // DCBA

String result = sb.toString(); // String 변환
System.out.println(result);    // DCBA
```

### 주요 메서드
- **append(String str)** : 끝에 문자열 추가
- **insert(int offset, String str)** : 특정 위치에 삽입
- **delete(int start, int end)** : 범위 삭제
- **reverse()** : 문자열 반전
- **toString()** : `String` 변환

---

## 4. 가변 vs 불변 비교

| 구분 | String (Immutable) | StringBuilder (Mutable) |
|------|--------------------|------------------------|
| 변경 시 동작 | 새로운 객체 생성 | 기존 객체 내부 값 변경 |
| 메모리 효율 | 낮음 | 높음 |
| 속도 | 느림 | 빠름 |
| 안전성 | 사이드 이펙트 없음 | 참조 공유 시 부작용 가능 |

---

## 5. String 최적화

### 5-1. 컴파일 시 문자열 리터럴 최적화
```java
String str = "Hello, " + "World!";
// 컴파일 후
String str = "Hello, World!"; // 이미 결합된 상태
```
→ 런타임 결합 불필요

### 5-2. 변수 문자열 결합 최적화
```java
String result = str1 + str2;
// 자바 9 이전
String result = new StringBuilder().append(str1).append(str2).toString();
```
→ 단순 문자열 결합은 최적화되지만, **반복문 내 결합은 비효율**

### 5-3. 반복문 내 문자열 결합 예시
```java
String result = "";
for (int i = 0; i < 100000; i++) {
    result += "Hello Java "; // 매번 객체 생성
}
```
→ `StringBuilder` 사용 권장

---

## 6. 메서드 체이닝 (Method Chaining)

### 6-1. 개념
- 메서드가 **자기 자신(this)**을 반환하여 **연속 호출** 가능하게 하는 패턴
- 코드 간결화, 가독성 향상

### 6-2. 예시 클래스
```java
public class ValueAdder {
    private int value;

    public ValueAdder add(int addValue) {
        value += addValue;
        return this; // 자기 자신 반환
    }

    public int getValue() {
        return value;
    }
}
```

### 6-3. 사용 방법
```java
ValueAdder adder = new ValueAdder();
int result = adder.add(1).add(2).add(3).getValue();
System.out.println(result); // 6
```

---

## 7. StringBuilder와 메서드 체이닝

`StringBuilder`의 `append()`, `insert()`, `delete()`, `reverse()` 등은 모두 자기 자신을 반환하여 **메서드 체이닝 가능**.

```java
String result = new StringBuilder()
                    .append("A")
                    .append("B")
                    .append("C")
                    .append("D")
                    .insert(4, "Java")
                    .delete(4, 8)
                    .reverse()
                    .toString();
System.out.println(result); // DCBA
```

---

## 8. 정리

- **String**: 불변, 안전성 높음, 변경 시 새 객체 생성 → 잦은 변경 시 비효율적
- **StringBuilder**: 가변, 변경 시 기존 객체 수정 → 성능 우수하지만 참조 공유 주의
- **메서드 체이닝**: 자기 자신 반환 → 메서드 연속 호출 가능, 코드 간결화
- **사용 권장**:
    - 문자열 변경이 적고 안전성이 중요 → `String`
    - 문자열 변경이 많거나 반복문 내 결합 → `StringBuilder`
