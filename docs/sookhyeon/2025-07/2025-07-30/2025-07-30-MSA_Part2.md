# 2-1. 프로젝트 구조 및 설계

## 좋은 구현이란?

1. **비즈니스 가치를 충족해야 한다**
    - 기술조직은 회사의 **비즈니스 지표**로 평가되어야 한다.
    - 기술은 **도구**일 뿐이며, 도구 선택의 목적은 비즈니스 목표 달성.

2. **가독성이 좋아야 한다**
    - 개발의 80%는 **코드 읽기**에 소모된다.
    - 별도 문서보다 **코드 자체**로 도메인을 설명할 수 있어야 함.

3. **테스트가 쉬워야 한다**
    - 테스트는 리팩토링과 기능 추가의 **안전장치**.
    - **의존성이 적을수록** 테스트 코드 작성이 쉬움.

4. **변경에 유연해야 한다**
    - 언제든 요구사항은 바뀔 수 있음 → **객체지향 설계 원칙** 적용 필요:
        - SRP (단일 책임 원칙)
        - OCP (개방/폐쇄 원칙)
        - LSP (리스코프 치환 원칙)
        - DIP (의존 관계 역전 원칙)
        - ISP (인터페이스 분리 원칙)

---

## 도메인 주도 설계 (DDD)

> 도메인을 중심으로 복잡한 시스템을 모델링하는 방식

### 기본 Layer 구성

| Layer | 역할 | 주요 객체 |
|-------|------|-----------|
| **Interfaces (UI)** | 사용자 명령 해석, 정보 표시 | `Controller`, `Dto`, `Mapper` |
| **Application** | 작업 조정 및 도메인 호출 | `Facade` |
| **Domain** | 핵심 비즈니스 로직, 규칙 | `Entity`, `Service`, `Command`, `Reader`, `Store`, `Executor`, `Factory` |
| **Infrastructure** | 기술 세부사항, 영속화 구현 | `StoreImpl`, `ReaderImpl`, `Spring JPA`, `RedisConnector` 등 |

### Layer 간 참조 원칙
- `Application`, `Infrastructure`는 `Domain`만 참조
- `Domain`은 어떤 기술에도 **독립적**이어야 함 (DIP 적용)

---

## 각 Layer 상세 정리

### 1. **Domain Layer**
- 비즈니스 핵심 로직 담당
- 기술적 세부사항은 위임
- 추상화된 interface 기반으로 설계

**예시 네이밍 규칙:**
- `OrderReader`, `PaymentStore`, `RefundExecutor`, `UserFactory`, `ScheduleAggregator`

**구현 전략:**
- 서비스 흐름을 `XXXService`로 구현
- 보조 로직은 다른 이름 사용
- Service 간 참조 지양

---

### 2. **Infrastructure Layer**
- 기술적 세부사항의 구현
- DIP를 적용하여 `Domain` 인터페이스를 구현
- Spring에서는 `@Component`로 구현하고, 역할에 따라 `@Service`와 구분

**허용 사항:**
- 구현체 간 참조 OK
- 단, **순환 참조 방지**와 **상하관계 명확화** 필요

---

### 3. **Application Layer**
- transaction 묶음 단위 조정
- 도메인 로직 직접 포함 X → 작업 조정만
- `XXXFacade` 네이밍 사용

**Facade 예시:**
```java
// 주문 완료 처리 후 알림
public void completeOrder(OrderRequest request) {
    orderService.completeOrder(request); // @Transactional
    notificationService.sendKakao(request); // 실패해도 롤백 안됨
}
```

---

### 4. **Interfaces Layer**
- 사용자 요청 수신, 응답 제공
- Request는 최소화, Response도 최소화가 바람직
- 통신 기술 (HTTP, gRPC, 메시징 등)은 이 Layer에서만 사용

**주의사항:**
- `Domain`에서 HTTP 요청 처리, JSON 파싱 등 **외부 기술 의존 금지**

---

## 요약 구조 (실제 코드 구조화 시 참고)

```
src/
├── interfaces/
│   └── controller/
├── application/
│   └── facade/
├── domain/
│   ├── entity/
│   ├── service/
│   ├── reader/
│   ├── store/
│   ├── executor/
├── infrastructure/
│   ├── repository/
│   ├── external/
```

---

## 결론

- 기술보다 도메인 중심 사고가 핵심
- 변경에 강한 유연한 구조 설계를 위한 레이어 분리
- 읽기 쉬운 코드, 테스트 가능한 구조, 객체지향 원칙 적용

---
---

# 2.2 권장하는 구현 방식

---

## 1. 개발 디자인 문서를 먼저 작성하자

- 개발 전 설계 문서 작성은 시행착오를 줄이고 방향성을 잡는 데 중요.
- 팀원과 공유하여 리뷰하면 더 나은 설계 유도 가능.
- 인수인계 시에도 유용.
- **29CM 개발 디자인 문서 양식 예시**:

| 항목 | 설명 |
|------|------|
| 문제정의 | - 배경 (현재 상황과 해결 방향)<br>- 필수 조건, 목표/비목표, 평가 기준 |
| 해결방안 | - 설계 (다이어그램 필수)<br>- 구현 스택, 테스트, 코드리뷰, 모니터링, 보안 |
| 배포 계획 | - 배포 대상, 전략, 방법 |
| 타임라인 | - 마일스톤 형태의 로드맵 |

---

## 2. 도메인 우선 설계

- DB 테이블 설계보다 도메인 모델 우선 도출이 중요.
- 객체 중심 개발은 ORM 도입 이후 강조됨.
- 우선 도메인 간 메시지 흐름을 설계해야 한다.
- 변수/메서드 이름은 유비쿼터스 언어 활용.
- 슬랙에 네이밍 전용 채널 운영도 추천.

---

## 3. API 설계 시 주의사항

- Request/Response는 꼭 필요한 필드만 유지.
- 불필요한 응답 필드는 제거, 남기면 변경 어려움 생김.
- 불필요한 request 필드는 객체가 너무 많은 책임을 지고 있다는 신호일 수 있음.
- `isAgreement` 같은 프로퍼티는 두 가지 행동을 암시하므로 설계 시 주의.

---

## 4. Setter 사용 최소화, 의미 있는 메서드로 분리

- Setter는 객체의 캡슐화를 깨는 주범.
- 객체 생성 시 필수값은 생성자, 상태 변경은 별도 메서드로 구현.

```java
public void markDeposited() {
    if (!this.status.equals(CREATED)) throw new IllegalStateException();
    this.status = DEPOSITED;
}
```

---

## 5. 트랜잭션과 도메인 저장소 설계

- 트랜잭션 범위는 작게 유지.
- 외부 시스템 호출은 가급적 트랜잭션 밖으로.
- 모든 도메인 객체가 저장소를 가지는 것은 아님.
   - 예: `Money` 객체는 DB 저장 없이 도메인 정합성 체크만 수행 → Value Object.

---

## 6. 예외 처리 원칙

- 불필요한 try-catch 금지.
- 의미 있는 예외처리가 없다면 그대로 throw.
- 예외 시 별도 작업이 필요할 경우만 try-catch 사용:

```java
try {
  increaseItem();
} catch (Exception e) {
  cancelItemManage();
  throw e;
}
```

---

## 7. 상태(State)는 꼭 필요한 것만 선언

- 상태값은 도메인 정체성과도 같음.
- 세분화된 상태는 도메인 이해도를 낮추고 코드 복잡도 증가.
- 기능 구현에 필요한 상태만 선언.

---

## 8. 테스트 코드와 빠른 구현 → 점진적 리팩토링

- 예상치 못한 버그는 테스트 코드로 예방.
- 동작하는 더러운 코드가, 안 되는 깔끔한 코드보다 낫다.
- 작동 가능한 코드 → 리팩토링으로 반복 개선.
- 리팩토링은 도메인 지식을 바탕으로 더 나은 구조를 만들 수 있는 시점에서 진행.

---

## 9. 하드코딩도 때로는 필요하다

- 약속된 런칭 일정은 무엇보다 중요.
- 일정 맞추기 위해 중복/하드코딩이 필요하면 용인하되,
   - 일시적 조치로 보고 정리 필요.
- 비즈니스 가치와 기술 품질의 균형이 중요.

---

## 핵심 요약

| 주제 | 실무 원칙 |
|------|-----------|
| 설계 문서 | 개발 전 반드시 작성, 리뷰 및 인수인계에도 효과적 |
| 도메인 우선 | 테이블보다 메시지 흐름 중심 도메인 모델 설계 |
| API | 불필요한 요청/응답 제거, 응답은 제한적으로 |
| Setter | 사용 최소화, 의미 부여된 메서드 활용 |
| 트랜잭션 | 범위 축소, 외부 호출 분리, 도메인 객체는 저장소 의존 X |
| 예외처리 | 무의미한 try-catch 제거, 의미 있는 경우만 사용 |
| 상태관리 | 기능 구현에 필요한 상태만 유지 |
| 테스트 | 주요 로직 테스트 필수, 리팩토링 반복 개선 |
| 하드코딩 | 일정 맞추기 위해 일시적 허용, 이후 정리 필수 |

---
