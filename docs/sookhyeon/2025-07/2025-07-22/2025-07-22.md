## Ch4. CPU

### Ch4-1. CPU의 구성 요소
- CPU는 ALU(산술 논리 연산), 제어 장치(명령 해석), 레지스터(임시 저장)로 구성된다.
- 플래그 레지스터는 연산 결과에 대한 상태 정보를 저장하며, 클럭 신호로 모든 동작이 동기화된다.

### Ch4-2. 레지스터 실습
- 프로그램 실행 흐름을 추적할 수 있는 핵심 장치는 레지스터이며, PC, IR, SP 등이 주요 레지스터이다.

### Ch4-3. 명령어 사이클과 인터럽트
- 명령어 인출 → 해석 → 실행 과정을 반복하며, 인터럽트를 통해 외부 이벤트에 대응한다.
- 동기(예외)와 비동기(하드웨어) 인터럽트가 존재하며, ISR을 통해 처리된다.

### Ch4-4. 멀티 코어와 멀티 스레드
- 멀티 코어는 병렬 실행을 위한 물리적 코어 확장, 멀티 스레드는 논리적 동시 실행을 의미한다.
- 성능 향상을 위한 대표적인 하드웨어 병렬화 기법이다.

### Ch4-5. 파이프라이닝
- 명령어를 여러 단계로 나누어 병렬 실행함으로써 처리 효율을 높인다.
- 데이터/제어/구조적 위험 요소가 존재하며, 슈퍼스칼라 구조로 극복 가능하다.

### Ch4-6. 비순차적 명령어 처리
- 순서에 의존하지 않는 명령어를 먼저 실행해 파이프라인 효율을 높인다.
- 명령어 간 의존성 분석이 핵심이며, 현대 CPU의 기본 실행 구조이다.

---

## Ch5. 메인 메모리와 캐시 메모리

### Ch5-1. RAM과 ROM
- RAM은 휘발성 메모리로 실행 중인 데이터를 저장하고, ROM은 비휘발성으로 펌웨어 등을 저장한다.
- DRAM, SRAM, Flash Memory 등 종류에 따라 속도와 사용처가 다르다.

### Ch5-2. 리틀 엔디안과 빅 엔디안
- 리틀 엔디안은 하위 바이트를 먼저 저장, 빅 엔디안은 상위 바이트를 먼저 저장한다.
- 시스템 간 데이터 전송 시 엔디안 불일치를 고려해야 하며, 네트워크는 빅 엔디안이 표준이다.

### Ch5-3. 논리 주소와 물리 주소
- CPU는 0번지부터 시작하는 논리 주소를 사용하고, MMU가 물리 주소로 변환한다.
- 주소 변환은 베이스 레지스터 등을 통해 수행된다.

### Ch5-4. 저장장치 계층과 캐시 메모리
- 저장 장치는 CPU에 가까울수록 빠르고 비싸며, 캐시는 메모리와 CPU 간 속도 차이를 보완한다.
- L1, L2, L3 캐시와 참조 지역성(시간/공간)이 캐시 효율에 핵심이다.

### Ch5-5. 캐시 친화적 코드
- 캐시 미스를 줄이기 위해 메모리 접근을 연속적이고 일관되게 구성해야 한다.
- 배열 순회 시 행 우선 접근 등 지역성 최적화가 중요하다.

---

## Ch6. 보조기억장치와 입출력장치

### Ch6-1. 하드 디스크와 플래시 메모리
- HDD는 물리 회전 기반이며 지연 시간이 크고, SSD는 반도체 기반으로 빠르다.
- 플래시 메모리는 셀 단위(SLC~QLC)에 따라 수명, 속도, 가격이 다르다.

### Ch6-2. RAID
- RAID는 여러 디스크를 하나처럼 구성해 성능과 안정성을 동시에 확보하는 기술이다.
- RAID 0(속도), RAID 1(복구), RAID 5/6(패리티 분산) 등 다양한 방식이 존재한다.

### Ch6-3. 입출력 기법
- 입출력은 프로그램 방식, 인터럽트 기반, DMA 방식으로 나뉜다.
- DMA는 CPU를 거치지 않고 장치와 메모리가 직접 통신하며, 고성능 입출력을 가능하게 한다.

