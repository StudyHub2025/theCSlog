[Part 3. 네트워크]

* Ch 4 전송 계층
  - TCP는 연결형 프로토콜
    1. 연결 설정 : **Three-way handshake**
       - Active Open : 연결을 요청하는 호스트 -> A
       - Passive Open : 연결 요청을 수락하는 호스트 -> B
         - 연결 순서
           1. 연결 요청 : A → B SYN 세그먼트 전송
           2. 연결 요청 응답 : B → A SYN+ACK 세그먼트 전송
           3. 연결 시작 알림 : A → B 세그먼트 전송
    2. 데이터 송수신
    3. 연결 종료
       - Active Close : 연결 종료를 요청하는 호스트 → A
         - Active Close  Host는 마지막 ACK을 보낸 뒤 **일정 시간을 기다리고 연결을 종료**한다
       - Passive Close : 연결 종료 요청을 수락하는 호스트 → B
       - 연결 종료 순서
         1. A→B 종료 요청 FIN 세그먼트 전송
         2. B→A 응답 ACK 세그먼트 전송
         3. B 종료 작업 진행
         4. B→A FIN 세그먼트 전송
         5. A→B ACK 세그먼트 전송  ⇒ B는 받자마자 종료
         6. A는 조금 기다렸다가 종료

----
 - TCP는 **연결형** 프로토콜 또는 **스테이트풀**(statefull) 프로토콜로도 불린다
   - 현재 연결 상태를 나타내기 위해 다양한 상태(state)활용
 - UDP는 **스테이트리스**(stateless) 프로토콜로도 불린다

 - TCP의 상태 목록
   - CLOSED : 아무런 연결이 없는 상태
   — — — 연결 수립 과정에서 많이 사용
   - **LISTEN** : SYN 세그먼트를 기다리는 상태 (서버 호스트)
   - **SYN-SENT** : SYN 세그먼트를 보낸 뒤 SYN+ACK 세그먼트 대기
   - **SYN-RECEIVED** : SYN+ACK 세그먼트를 보낸 뒤 그에 대한 ACK 대기
   — — —
   - ESTABLISHD : 현재 데이터 송수신이 가능한 상태(연결 되어 있는 상태)
   — — —연결 종료 과정에서 많이 사용
   - FIN-WAIT-1
   - FIN-WAIT-2
   - CLOSE-WAIT : 어플리케이션 프로세스들이 모두 정상적으로 종료될 때까지 대기하는 상태
   - CLOSING
   - LAST-ACK
   - TIME-WAIT : 일정 시간 대기 후 종료
   — — —

----
 - TCP는 신뢰성 프로토콜
   - 정확하고 안전한 데이터 전송을 보장하기 위해 TCP는 다양한 신뢰성 메커니즘을 제공
     → **재전송 기반의 오류 제어**: 잘못 전송된 경우 재전송
     → 흐름 제어 : 받을 수 있을 만큼만 받기
     → 혼잡 제어 : 보낼 수 있는 상황에서만 보내기

- 패킷 유실 판단 방법
  1. 중복된 ACK 세그먼트를 수신했을 때
  2. 타임아웃이 발생했을 때
     - 운영체제에서는 송수신 시 재전송 타이머라는 값을 생성 및 관리하고 있음
       해당 타이머에서 타임 아웃이 발생했을 경우를 말함

- **재전송 기반의 오류 제어**
  - 재전송을 기반으로 잘못된 전송을 바로 잡는 것으로 **ARQ**(자동 재전송 요구) 라고 부른다
    - ARQ 종류
      - Stop-and-Wait ARQ → 현재 TCP에서 잘 사용 안 함
        - 가장 단순한 형태
        - 제대로 보냈음을 확인하기 전까지는 그 다음 준비가 되어 있어도 보내지 않음
        - 전송하고, 확인하고, 전송하고, 확인하고, ...
        - 네트워크 이용 효율이 낮아지는 문제 발생
          → 해결 방법? 여러 세그먼트를 한번에 전송하는 **파이프라이닝** 기법 사용
      - Go-Back-N ARQ
        - 파이프라이닝 기법으로 동작
        - 올바른 세그먼트에 대해서는 확인 응답 보냄
        - 올바르지 않은 세그먼트(e.g. N번 세그먼트)가 수신되면 이후(N+1번 이후) 모든 세그먼트 폐기
        - 누적 확인 응답(Cumulative ACK)
      - Selective Repeat ARQ
        - 파이프라이닝 기법으로 동작
        - 올바른 세그먼트에 대해서만 확인 응답 보냄
        - 각 세그먼트에 대한 확인 응답: 개별 확인 응답
        - 보낸 쪽에서 손실된 세그먼트를 확인하고 재전송
      - 참고 : ARQ에서는 Go-Back-N ARQ, Selective Repeat ARQ 혼용해서 사용하는 경우가 많다

----
 - TCP는 신뢰성 프로토콜
   - 정확하고 안전한 데이터 전송을 보장하기 위해 TCP는 다양한 신뢰성 메커니즘을 제공
     → 재전송 기반의 오류 제어: 잘못 전송된 경우 재전송
     → **흐름 제어** : 받을 수 있을 만큼만 받기
     → **혼잡 제어** : 보낼 수 있는 상황에서만 보내기

- 송신 버퍼와 수신 버퍼
  - 송신 버퍼: 어플리케이션 계층에서 전송할 데이터 임시 저장
  - 수신 버퍼: 네트워크 계층에서 수신할 데이터 임시 저장
   
- ARQ에서 파이프라이닝 기법을 사용하는데 이에 따른 고려 사항
  - 송수신 한계를 알아야 한다 (버퍼의 한계 라고도 부름)
    만약 송신 호스트가 수신 호스트가 처리할 수 있는 수신 버퍼보다 더 많은 데이터를 전송한다면?
    → **버퍼 오버플로우** 발생되어 일부 데이터가 처리되지 않을 수 있음
    → 흐름 제어 필요

- 흐름 제어
  - 송신 호스트가 수신 호스트 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 것
    - 수신 호스트가 송신 호스트한테 **수용할 수 있는 양**을 **TCP 헤더의 윈도우 필드에 담아 전송**
  - 오늘날 TCP에서의 흐름 제어 → 슬라이딩 윈도우(sliding window)
  - 윈도우
    - 윈도우 : 파이프라이닝이 가능한 순서 번호 범위
    - 윈도우 크기 : 확인 응답 받지 않고도 한번에 보낼 수 있는 최대 양
    - 송수신 호스트별 윈도우 값
      - 수신 호스트
        - 수신 윈도우 = 수신 버퍼 크기 - [마지막으로 수신한 바이트 - 마지막으로 읽어들인 바이트]
          - 연산된 수신 윈도우 값을 송신 호스트에 전송
      - 송신 호스트
        - 수신 윈도우 >= 마지막으로 송신한 바이트 - 마지막으로 수신 확인된 바이트
          - 즉, (마지막으로 송신한 바이트 - 마지막으로 수신 확인된 바이트) 값이 수신 윈도우 값보다 크지 않도록 전송해야 한다

 - 혼잡(congestion) 제어
   - 많은 트래픽으로 인해 패킷 처리 속도가 느려지거나 유실 될 우려가 있는 상황
     → 혼잡 붕괴 현상 발생
   - 혼잡 붕괴 현상을 방지하기 위해 생성된 기법
   - 혼잡이 생기지 않을 정도로만 조금씩 전송하는 방법
   - 혼잡 윈도우
     - 혼잡 없이 전송할 수 있을 법한 양
     - 수신지에서는 굳이 알 필요 없는 정보이기 때문에 헤더에 포함되지 않는다
     - 송신 호스트
       최소값(수신 윈도우, 혼잡 윈도우) >= 마지막으로 송신한 바이트 - 마지막으로 수신 확인된 바이트
     - 기본 동작 형태 : AIMD(Additive Increase Multicative Decrease)
     - 알고리즘 (혼잡 제어를 수행하는 알고리즘)
       - 느린 시작 (slow start)
       - 혼잡 회피 : 매 RTT마다 혼잡 윈도우를 1씩 증가 (선형적 증가)
       - 빠른 회복 : 세 번의 중복 ACK 세그먼트가 수신 되었을 때 느린 시작을 건너뛰고 혼잡 회피를 수행하는 알고리즘


* Ch 5 응용 계층
  - DNS 프로토콜
    - 사람이 기억하기 쉬운 도메인 이름과 호스트를 특정 지을 주소를 매핑
      - 도메인 : 호스트에 부여되는 문자열 이름( ex) google.com)
      - 서브 도메인(하위 도메인) : 도메인의 일부인 도메인
        - naver.com → **maps**.naver.com / **mail**.naver.com
          wikipedia.com → **en**.wikipedia.com / **ko**.wikipedia.com
      - DNS 서버
        - 처음 접하는 도메인의 IP주소를 찾을 때 DNS 서버 요청
        - DNS서버는 계층적인 구조를 가지고 있다
        - 각 도메인을 담당하는 도메인 서버
          - ROOT 네임 서버 → 최상위 도메인 서버
          - TLD 서버
          - Authoritative DNS 서버 (책임 DNS 서버) : 찾고자 하는 도메인의 IP주소를 저장하는 최종 서버
          - local DNS 서버: 클라이언트가 가장 먼저 찾는 DNS 서버 (DNS Resolver)
            - 설정 방법
                - local DNS 서버 주소 명시적 설정 : Public DNS
                    - 장점 : 내가 접속하고자 하는 도메인이 Public DNS와 가까운 곳에 위치하면 ISP보다 빠르다
                - local DNS 서버 주소 자동 설정 : ISP
                    - DHCP로 IP를 자동으로 할당 받을 때, DNS도 자동으로 입력된다

  - DNS 동작
    - 재귀적 질의
    - 반복적 질의
      1. 컴퓨터에서 gaia.cs.umass.edu 접속 요청
      2. host에서는 처음 접근하는 DNS여서 local DNS Server에 문의
      3. local DNS Server는 Root → TLD → … → …  IP주소를 아는 DNS 서버까지 계속 질의응답 진행
      4. authoritative DNS server에서 IP 주소를 알아냄
      5. 알아낸 IP 주소를 호스트에 전달
      
  - DNS 서버에 저장되는 데이터
    - DNS 레코드( 자원 레코드) 
      - 주요 데이터
        - A레코드 : IPv4 주소와 도메인을 1:1 매칭
        - AAAA레코드 : IPv6 주소와 도메인을 1:1 매칭
        - CNAME : 도메인에 대한 별칭
        - ...

----
 - 네트워크 상에서의 '자원'
   - 네트워크로 주고받을 수 있는 모든 정보
   - 파일, 이미지, 동영상, HTML, XML, JSON, …
   - 네트워크 상에서의 '자원'이 필요하다면 자원을 요청해야 함
     자원을 요청하고 요청한 자원을 응답하려면 자원을 식별(identify)할 수 있어야 함
     즉, 자원의 식별자(identifier) == Uniform Resource Identifier 필요

 - URI
   - 자원을 식별할 수 있는 문자열
   - URI 분류 방법 (URI는 위치 혹은 이름으로 분류 가능)
     - **URL: 위치 기반 자원 식별(Locator)**
     - URN: 이름 기반 자원 식별(Name)

 - URL 구성 요소
   - scheme : 어떤 식으로 데이터를 주고 받을지에 대한 방법이 명시 됨
     - **https**://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
       **ftp**://ftp.kernel.org/
       **http**://example.com
   - authority = [ userinfo "@" ] host [ ":" port ]
     - [ userinfo "@" ] = 사용자 이름을 이용한 인증 가능 (생략 가능)
     - host = 호스트 이름 (도메인 이름 혹은 IP 주소)
     - [ ":" port ] = 포트 번호 (생략 가능)
       - https://**www.iana.org**/_img/2015.1/iana-logo-header-notext.svg
       _ https://**myblog**/posts/50
   - path : 자원이 있는 경로
     - https://www.iana.org**/_img/2015.1/iana-logo-header-notext.svg**
     - https://myblog**/posts/50**
   - query 
     - key:value 형태로 서버에 전달할 문자 형태의 파라미터
       ?로 시작, & (혹은;)로 다수의 query 구분
     - https://www.google.com/search**?q=fastcampus&hl=ko**
   - fragment 
     - 자원의 조각(fragment)를 가리키는 데에 사용 (#로 구분)
     - 북마크 기능을 구현할 때 많이 사용 / html에서 특정 위치를 나타내는데 사용 
     - https://docs.python.org/ko/dev/howto/sockets.html**#creating-a-socket**
     - https://docs.python.org/ko/dev/howto/sockets.html**#ipc**

----
 - 서버
   - 웹 서버
     - 정적인 자원을 응답 하는 서버
       * 정적인 자원 : 언제/어디서/누가 봐도 변하지 않는 정보 (ex  HTML, 이미지, 동영상…)
   - 웹 어플리케이션 서버 (WAS)
     - 동적인 자원을 응답 하는 서버
       * 동적인 자원 : 언제/어디서/누가 보는지에 따라 **변할 수 있는 정보**
         → 동적인 자원에서 주로 사용되는 것이 데이터베이스
       * ex) 로그인 사용자별 이름 구분 / 오늘의 날씨

 - 웹 서비스
   - 대부분 웹 서버와 웹 어플리케이션 서버를 같이 사용한다
     - 과도한 부하 방지 가능
     - 보안적으로 좋다
       * 특정 웹 어플리케이션 서버에 접속 하려면 특정 웹 서버에 접속해야 하는 경우,
         웹 서버 쪽 보안을 높이면 웹 어플리케이션 서버 보안도 같이 높일 수 있다
     - 여러 웹 어플리케이션 서버와 연동이 용이
 