[Part 1. 컴퓨터 구조]

* Ch 1. 오리엔테이션

###프로그램을 구성하는 두 가지 정보
- 명령어 (Instruction) : 컴퓨터를 실제로 동작하게 하는 정보
- 데이터 (Data) : 명령어의 대상이 되는 정보 (즉, 연산의 재료)

###컴퓨터의 네 가지 핵심 부품
| 구성 요소                 | 역할                                                      |
| --------------------- | ------------------------------------------------------- |
| **CPU (중앙처리장치)**      | 명령어를 **가져오고(Fetch)**, **해석하고(Decode)**, **실행(Execute)** |
| **메인 메모리 (RAM)**      | 실행 중인 프로그램 및 데이터를 저장하는 휘발성 저장 장치                        |
| **보조 기억장치 (SSD/HDD)** | 데이터를 장기적으로 저장하는 비휘발성 장치                                 |
| **입출력 장치 (I/O)**      | 컴퓨터 외부와 데이터를 주고받는 장치 (예: 키보드, 모니터 등)                    |

##CPU 구성
- 레지스터: CPU 내부에 있는 작고 빠른 임시 저장장치
- ALU (산술논리연산장치): 덧셈, 뺄셈, 논리 연산 등을 수행하는 계산기 회로
- 제어 장치 (Control Unit): 명령어를 해석하고, 필요한 **제어 신호(Control Signal)**를 생성

##메인 메모리와 캐시 메모리
- 메인 메모리(RAM): 실행 중인 프로그램 데이터를 저장
- 캐시 메모리: CPU와 메인 메모리 사이에 위치, 속도 향상을 위한 보조 메모리
* 특징: 휘발성 (전원이 꺼지면 데이터가 사라짐)

##보조 기억장치
- 전원이 꺼져도 보존해야 할 데이터를 저장
* 특징 : 비휘발성 저장장치 (전원이 꺼져도 데이터 유지)
* 예시 : SSD, HDD

##입출력 장치
- 사용자 또는 외부 장치와 정보를 주고받는 기능
* 예시 : 마우스, 프린터, 스피커, USB 등

###메인보드(마더보드)
- 컴퓨터의 네 가지 핵심 부품을 연결하고 통합하는 기판
- 버스(Bus) : 부품 간 정보를 주고받는 전송 통로 
    - 시스템 버스: CPU, 메모리, I/O 장치를 연결하는 주요 버스
    - 그 외 주소 버스, 데이터 버스, 제어 버스 등이 있다

--------------------------------------------------------------------------------------
* Ch 2. 명령어

###소스코드와 명령어
- 소스 코드 : 사람이 이해하기 쉬운 고급 언어
- 명령어와 데이터 : 컴퓨터가 직접 이해하는 저급 언어 (기계어, 어셈블리어)
- 고급 언어로 작성된 소스 코드는 내부적으로 저급 언어로 구성된 명령어와 데이터로 변환된다.

##저급 언어 종류
- 기계어 (Machine Code): CPU가 직접 이해하는 이진 코드
- 어셈블리어 (Assembly Language): 기계어를 사람이 읽기 쉽게 표현한 코드
- 참고 : CPU나 컴파일러 종류에 따라 기계어와 어셈블리어는 달라질 수 있음.

###소스 코드를 명령어로 변환하는 방법(두 가지의 대표 방식)
- 컴파일 (Compile)
  - 전체 소스 코드를 한 번에 기계어로 변환 후 실행 파일 생성
  - 예시: C, C++, Rust
  - 장점: 실행 속도 빠름
  - 단점: 컴파일 오류가 있으면 실행 불가

- 인터프리트 (Interpret)
  - 한 줄씩 소스 코드를 해석하며 실행
  - 예시: Python, JavaScript
  - 장점: 즉시 실행 가능, 부분 실행 가능
  - 단점: 컴파일보다는 속도가 느리다

- 컴파일과 인터프리트의 경계가 명확하지 않은 언어도 존재 (예: Java, Python 컴파일러)

###명령어의 구조
**명령어는 ‘무엇을(연산코드, OP 코드)’ 하고, ‘무엇을 대상으로(오퍼랜드, operand)’ 수행하라는 의미를 가진다**

##구성 요소
- 연산 코드 (OP 코드) : 수행할 동작(연산 종류)
- 오퍼랜드 (Operand) : 연산 대상 데이터 또는 데이터 위치(레지스터, 메모리 주소 등)
  - 오퍼랜드 수는 0개부터 3개 이상까지 다양하다
  - 연산 코드 종류는 CPU 마다 다르지만, [데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어]는 거의 공통적으로 사용되고 있다

###주소 지정
- 주소 지정**이란? 
  명령어 내 연산 대상 데이터가 직접 포함되지 않을 때, 데이터가 저장된 위치(주소)를 찾는 방법을 의미
- 왜 직접 데이터를 명시하지 않는지?
  - 명령어 길이 제한 때문에 큰 데이터는 명령어 내에 다 담기 어렵다
  - 위치를 명시하고 필요한 데이터는 그 주소에서 불러온다

###주소 지정 방식 
- 즉시 주소 지정 (Immediate) 
  - 오퍼랜드 필드에 연산할 데이터가 직접 명시됨	
  - 빠르고 간단, 데이터 크기 제한 있음
- 직접 주소 지정 (Direct)	
  - 오퍼랜드 필드에 데이터가 저장된 메모리 주소가 명시됨	
- 간접 주소 지정 (Indirect)	
  - 오퍼랜드 필드에 데이터 주소를 저장한 메모리 주소가 명시됨 (주소의 주소)	
- 레지스터 주소 지정 (Register)	
  - 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시 (즉, 레지스터 이름이 명시)	
- 레지스터 간접 주소 지정 (Register Indirect)	
  - 연산에 사용될 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시 

- 참고 : 레지스터 접근이 메모리 접근보다 빠르기 때문에 메모리보다 레지스터를 명시 하는 경우가 많다

--------------------------------------------------------------------------------------
* Ch 3. 데이터

###데이터를 표현하는 방법 (대표 예시)
- 양수 : 이진수 (Binary)
- 음수 : 2의 보수 (Two's complement)
- 소수 : 부동 소수점 (Floating-point)
- 문자 : 문자 집합 + 인코딩 방식

##양수 → 이진수(Binary)
- 2진법: 0과 1로 모든 수를 표현하는 방식 
  - 예시 : 10(십진수) → 1010(2) (이진수)
  - 이진수는 너무 길어지기 때문에 → 16진수를 사용 
    - 16진법: 09 + AF로 구성
    - 표기법: 0x1F 또는 1F(16)

##음수 → 2의 보수(Two's Complement)
- 컴퓨터는 부호(+, -)를 표현할 수 없으므로 음수를 2의 보수로 표현
- 방법 
  1. 숫자를 이진수로 표현
  2. 모든 비트를 반전 (1의 보수)
  3. +1 하면 2의 보수 완성
  예시 : 0000 0011 (3) → 반전 1111 1100 → +1 → 1111 1101 → -3
- 양수/음수 구분은 어떻게? 
  - Flag 레지스터의 "음수 플래그" 사용
  - 플래그가 셋팅되면 음수,아닐 경우엔 양수

##소수 표현 → 부동 소수점(Floating-Point)
| 구성 요소            | 역할                         |
| ---------------- | -------------------------- |
| 부호 비트 (sign bit) | 0: 양수, 1: 음수               |
| 지수 (Exponent)    | 소수점 이동 횟수 (바이어스 적용됨)       |
| 가수 (Significand) | 실제 소수값 (1.xxx 형식에서 1은 생략됨) |
* 바이어스(Bias): 지수에서 음수를 피하기 위해 일정 수를 더해서 저장

##문자 -> 문자 집합(Character Set) + 인코딩(Encoding)
- 문자 집합 (Character Set) : 컴퓨터가 이해할 수 있는 문자들의 모음
- 인코딩 (Encoding) : 문자를 0과 1로 바꾸는 과정
- 디코딩 : 인코딩의 반대 과정

##대표적인 방식
- ASCII 
  - 초창기 문자 인코딩 방식
  - 7비트로 128개 문자 표현 (영문자, 숫자, 특수문자 등)
  - 8비트 중 1비트는 오류 검출용