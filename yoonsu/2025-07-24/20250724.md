### ch 3. CPU 스케줄링

#### 프로세스 우선순위
- PR,NI 낮을수록 우선순위
- 우선순위:  I/O bound process > CPU bound process(컴파일작업)

#### 스케줄링
- 선점형: 문맥교환과정의 오버헤드
- 비선점형

#### 스케줄링 큐
- 준비 큐, 대기 큐

#### CPU 스케줄링 알고리즘
- FIFO 스케줄링 : 비선점형, 호위효과
- SJF 스케줄링 : 최단작업우선
- RR 스케줄링 : 라운드로빈, 선점형
- SRT 스케줄링 : 최소잔여시간우선
- 우선순위 스케줄링 : 아사현상(해결:에이징, 대기시간이 길어지면 우선순위 높이기)
- 다단계 큐 스케줄링 : 아사현상
- 다단계 피드백 큐 스케쥴링 : 프로세스가 큐간의 이동가능

### ch 4. 동기화와 교착상태
#### 프로세스 동기화
- 일관성
- 공유자원
- 임계구역 : 레이스컨디션(동시에 임계구역에 접근하여 발생하는 현상)
- 뮤텍스 락
- 세마포 : 상호배제 & 실행순서 제어를 위한 동기화 도구, wait({while(s<=0); s--}), signal({s++})

| 구분           | 뮤텍스(Mutex)           | 세마포어(Semaphore)              |
|----------------|-------------------------|---------------------------------|
| 접근 허용 개수  | 1개만 허용              | N개 허용 (N ≥ 1)                |
| 사용 목적      | 상호 배제, 임계 영역 보호 | 제한된 수의 자원 접근 제어         |
| 소유권 개념    | 락을 획득한 스레드만 해제 가능 | 해제하는 스레드가 반드시 락 획득자일 필요 없음 |
| 동작 방식      | 락 획득 → 작업 → 락 해제   | 카운터 감소 → 작업 → 카운터 증가  |
| 대표적 용도    | 공유 변수 보호           | 커넥션 풀, 제한된 리소스 관리      |
| 예            | Java `ReentrantLock`     | Java `Semaphore`                 |

#### 조건변수와 모니터
 - 조건변수 실행순서 제어 : wait() -> 대기상태 진입 -> notify()
 - 모니터 : 하나의 공유 자원에 대해 하나의 스레드만 접근하도록 보장하는 동기화 메커니즘

#### 교착상태
- 일어나지않을 사건을 무한히 대기
- 발생조건 : 상호배제, 점유와 대기, 비선점, 원형 대기
- 예방, 검출, 회

### ch 5. 가상 메모리 관리

#### 연속 메모리 할당
- 초기 메모리 관리 방식
- 외부 단편화 발생

#### 페이징(Paging)
- 가상메모리를 고정 크기의 페이지로 나누고, 물리 메모리는 프레임으로 분할하여 매핑
- 내부 단편화 발생 가능

#### 페이지 테이블
- 페이지와 프레임 매핑 정보 저장
- 프로세스마다 하나씩 존재
- 크기 문제 → 다단계 페이지 테이블(계층적) 사용
- 메타정보:
- 보호 비트: 읽기/쓰기 권한
- 참조 비트: 접근 여부
- 수정 비트: 수정 여부

#### TLB (Translation Lookaside Buffer)
- 페이지 테이블의 캐시 역할
- 빠른 주소 변환

#### 페이지 폴트(Page Fault)
- 필요한 페이지가 메모리에 없음 → 보조기억장치에서 불러옴
- 처리 절차:
  1. 작업 중단 및 백업 
  2. 페이지 폴트 루틴 실행 
  3. 페이지 적재 후 유효 비트(valid bit) 설정 
  4. 다시 접근


#### 페이징
- 가상메모리 관리기법
- 세그멘테이션 : 외부단편화
- 내부단편화
- 페이지테이블: 프레임과 페이지 매핑정보를 담고있는 표형태의 데이터, 프로세스마다 소유
- 계층적 테이블
- TLB : 페이지 테이블의 캐시메모리
  - 보호비트
  - 참조비트
  - 수정비트
- 페이지폴트 : 접근하려는 페이지가 메모리에 적재x, 보조기억장치에
  - 작업내역 백업
  - 페이지폴트루틴 실행- 접근하려는 페이지 적재
  - 유효비트 1
  - 페이지접근
- 연속메모리할당 : 외부 단편화 문제, 용량 낭비
- 메모리 프레임 = 프로세스 페이지
- 페이지에 프레임을 할당
#### 가상메모리
- 메모리보다 큰 가상 주소 공간 사용 가능
- 페이지만 메모리에 적재 → 효율적 사용
- 
#### 스왑
- 메모리가 부족할 때 사용하지 않는 페이지를 디스크로 이동

#### 페이지 교체 알고리즘
- 페이지 참조열 : CPU 가 참조하는 페이지 중 녕속된 페이지를 생략한 페이지열
- FIFO 페이지 교체 알고리즘 :
- 2차 기회 FIFO 페이지 교체 알고리즘 : 참조비트(1일 경우 0으로 변경 후 한번 더 기회 부여)
- 최적 페이지 교체 알고리즘 : 앞으로 사용빈도가 가장 낮은 페이지(예측이 어려움)
- LRU 페이지 교체 알고리즘 : 가장 적게 참조한 페이지 교체

#### 쓰기 시 복사 (copy-on-write)
- 자식 프로세스와 부모프로세스 자원 공유하다 쓰기 시 복사 후 자원따로사용
